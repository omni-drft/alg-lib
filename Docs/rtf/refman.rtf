{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;\red0\green128\blue0;\red96\green64\blue32;\rede0\green128\blue0;\red128\green0\blue0;\red128\green96\blue32;\red0\green32\blue128;\red0\green128\blue128;\red255\green0\blue255;\red0\green0\blue0;\red112\green0\blue112;\red255\green0\blue0;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\paperw11900\paperh16840\margl1800\margr1800\margt1440\margb1440\gutter0\ltrsect}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s6\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs12\cgrid \sbasedon0 \snext0 heading 6;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext50 Code Example 9;}
{\s50\li3600\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext51 Code Example 10;}
{\s51\li3960\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext52 Code Example 11;}
{\s52\li4320\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 12;}
{\s53\li4680\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 13;}
{\s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext61 List Continue 0;}
{\s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext62 List Continue 1;}
{\s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext63 List Continue 2;}
{\s63\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext64 List Continue 3;}
{\s64\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext65 List Continue 4;}
{\s65\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext66 List Continue 5;}
{\s66\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext67 List Continue 6;}
{\s67\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext68 List Continue 7;}
{\s68\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext69 List Continue 8;}
{\s69\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext70 List Continue 9;}
{\s70\li3600\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext71 List Continue 10;}
{\s71\li3960\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext72 List Continue 11;}
{\s72\li4320\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 12;}
{\s73\li4680\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 13;}
{\s80\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext81 DescContinue 0;}
{\s81\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext82 DescContinue 1;}
{\s82\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext83 DescContinue 2;}
{\s83\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext84 DescContinue 3;}
{\s84\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext85 DescContinue 4;}
{\s85\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext86 DescContinue 5;}
{\s86\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext87 DescContinue 6;}
{\s87\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext88 DescContinue 7;}
{\s88\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext89 DescContinue 8;}
{\s89\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext90 DescContinue 9;}
{\s90\li3600\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext91 DescContinue 10;}
{\s91\li3960\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext92 DescContinue 11;}
{\s92\li4320\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 12;}
{\s93\li4680\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 13;}
{\s100\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext101 LatexTOC 0;}
{\s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext102 LatexTOC 1;}
{\s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext103 LatexTOC 2;}
{\s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext104 LatexTOC 3;}
{\s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext105 LatexTOC 4;}
{\s105\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext106 LatexTOC 5;}
{\s106\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext107 LatexTOC 6;}
{\s107\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext108 LatexTOC 7;}
{\s108\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext109 LatexTOC 8;}
{\s109\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext110 LatexTOC 9;}
{\s110\li3600\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext111 LatexTOC 10;}
{\s111\li3960\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext112 LatexTOC 11;}
{\s112\li4320\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 12;}
{\s113\li4680\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 13;}
{\s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext121 \sautoupd List Bullet 0;}
{\s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext122 \sautoupd List Bullet 1;}
{\s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext123 \sautoupd List Bullet 2;}
{\s123\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext124 \sautoupd List Bullet 3;}
{\s124\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext125 \sautoupd List Bullet 4;}
{\s125\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext126 \sautoupd List Bullet 5;}
{\s126\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext127 \sautoupd List Bullet 6;}
{\s127\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext128 \sautoupd List Bullet 7;}
{\s128\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext129 \sautoupd List Bullet 8;}
{\s129\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext130 \sautoupd List Bullet 9;}
{\s130\fi-360\li3960\widctlpar\jclisttab\tx3960{\*\pn \pnlvlbody\ilvl0\ls11\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext131 \sautoupd List Bullet 10;}
{\s131\fi-360\li4320\widctlpar\jclisttab\tx4320{\*\pn \pnlvlbody\ilvl0\ls12\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext132 \sautoupd List Bullet 11;}
{\s132\fi-360\li4680\widctlpar\jclisttab\tx4680{\*\pn \pnlvlbody\ilvl0\ls13\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 12;}
{\s133\fi-360\li5040\widctlpar\jclisttab\tx5040{\*\pn \pnlvlbody\ilvl0\ls14\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 13;}
{\s140\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext141 \sautoupd List Enum 0;}
{\s141\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext142 \sautoupd List Enum 1;}
{\s142\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext143 \sautoupd List Enum 2;}
{\s143\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext144 \sautoupd List Enum 3;}
{\s144\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext145 \sautoupd List Enum 4;}
{\s145\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext146 \sautoupd List Enum 5;}
{\s146\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext147 \sautoupd List Enum 6;}
{\s147\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext148 \sautoupd List Enum 7;}
{\s148\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext149 \sautoupd List Enum 8;}
{\s149\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext150 \sautoupd List Enum 9;}
{\s150\fi-360\li3960\widctlpar\fs20\cgrid \sbasedon0 \snext151 \sautoupd List Enum 10;}
{\s151\fi-360\li4320\widctlpar\fs20\cgrid \sbasedon0 \snext152 \sautoupd List Enum 11;}
{\s152\fi-360\li4680\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 12;}
{\s153\fi-360\li5040\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 13;}
}
{\*\listtable
{\list\listtemplateid1
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u8226 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li360 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9702 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li720 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9642 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1080 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u8226 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1440 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9702 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1800 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9642 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2160 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u8662 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2520 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9702 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2880 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9642 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li3600 }
\listid1}
{\list\listtemplateid2
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li360 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li720 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1080 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1440 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1800 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2160 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2520 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2880 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li3600 }
\listid2}
{\list\listtemplateid3
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li360 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li720 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1080 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1440 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1800 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2160 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2520 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2880 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li3600 }
\listid3}
}
{\listoverridetable
{\listoverride\listid1\listoverridecount0\ls1}
{\listoverride\listid2\listoverridecount0\ls2}
{\listoverride\listid3\listoverridecount0\ls3}
}
{\info 
{\title {\comment AlgLib  {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
1.0.0 \par
}}AlgLib}
{\comment Generated by doxygen 1.13.2.}
}\pard\plain 
\sectd\pgnlcrm
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\vertalc\qc\par\par\par\par\par\par\par
\pard\plain \s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid 
{\field\fldedit {\*\fldinst TITLE \\*MERGEFORMAT}{\fldrslt AlgLib}}\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\par
\par\par\par\par\par\par\par\par\par\par\par\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
{\field\fldedit {\*\fldinst AUTHOR \\*MERGEFORMAT}{\fldrslt AUTHOR}}\par
Version 1.0.0\par\page\page\vertalt
\pard\plain 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Table of Contents\par
\pard\plain \par
{\field\fldedit {\*\fldinst TOC \\f \\*MERGEFORMAT}{\fldrslt Table of contents}}\par
\pard\plain 
\sect \sbkpage \pgndec \pgnrestart
\sect \sectd \sbknone
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Namespace Index\par \pard\plain 
{\tc \v Namespace Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Namespace List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all namespaces with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b alglib} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default namespace for the AlgLib library })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b alglib::errors} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Namespace for errors in the AlgLib library })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Class Index\par \pard\plain 
{\tc \v Class Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Class List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here are the classes, structs, unions and interfaces with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b alglib::ArrayStack< T, capacity >} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Template based stack implementation that uses an array as a base structure. It doesn't allocate memory on the heap, but it has a fixed capacity that has to be defined at compile time })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b alglib::CircularQueue< T, capacity >} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CircularQueue} class is a queue data structure implemented using an array. It doesn't allocate memory on the heap and has a fixed capacity that has to be defined at compile time. It uses a circular buffer to store elements })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b alglib::DoublyLinkedList< T >} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Template based doubly linked list implementation. All nodes are dynamically allocated })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b alglib::SinglyLinkedList< T >} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Template based singly linked list implementation. All nodes are dynamically allocated })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b alglib::SLLQueue< T >} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b SLLQueue} class is a queue data structure implemented using singly linked list. It allocates nodes on the heap. Queue can grow dynamically. There is no limit to the amount of elements besides the memory available })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b alglib::SLLStack< T >} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b SLLStack} is a stack implementation that uses a singly linked list as a base structure. It allocates memory on the heap, so the stack can grow dynamically })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b alglib::Vector< T >} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Template based vector implementation that uses an array as a base structure. It allocates memory on the heap, and it can grow dynamically. Capacity doubles every time the size exceeds current capacity })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Index\par \pard\plain 
{\tc \v File Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
File List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all files with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b Include/{\b alg_lib.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Include/{\b array_stack.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Include/{\b circular_queue.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Include/{\b constants.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Include/{\b doubly_linked_list.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Include/{\b singly_linked_list.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Include/{\b sll_queue.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Include/{\b sll_stack.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Include/{\b vector.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Namespace Documentation\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
alglib Namespace Reference\par \pard\plain 
{\tc\tcl2 \v alglib}
{\xe \v alglib}
{\bkmkstart AAAAAAAAAS}
{\bkmkend AAAAAAAAAS}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default namespace for the AlgLib library. }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b errors}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Namespace for errors in the AlgLib library. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ArrayStack}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Template based stack implementation that uses an array as a base structure. It doesn't allocate memory on the heap, but it has a fixed capacity that has to be defined at compile time. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CircularQueue}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CircularQueue} class is a queue data structure implemented using an array. It doesn't allocate memory on the heap and has a fixed capacity that has to be defined at compile time. It uses a circular buffer to store elements. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DoublyLinkedList}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Template based doubly linked list implementation. All nodes are dynamically allocated. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b SinglyLinkedList}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Template based singly linked list implementation. All nodes are dynamically allocated. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b SLLQueue}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b SLLQueue} class is a queue data structure implemented using singly linked list. It allocates nodes on the heap. Queue can grow dynamically. There is no limit to the amount of elements besides the memory available. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b SLLStack}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b SLLStack} is a stack implementation that uses a singly linked list as a base structure. It allocates memory on the heap, so the stack can grow dynamically. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Vector}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Template based vector implementation that uses an array as a base structure. It allocates memory on the heap, and it can grow dynamically. Capacity doubles every time the size exceeds current capacity. }}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default namespace for the AlgLib library. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default namespace for the library. \par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
alglib::errors Namespace Reference\par \pard\plain 
{\tc\tcl2 \v alglib::errors}
{\xe \v alglib::errors}
{\bkmkstart AAAAAAAADT}
{\bkmkend AAAAAAAADT}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Namespace for errors in the AlgLib library. }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr const char * {\b kItemNotFound} \{"Item not found."\}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr const char * {\b kIndexOutOfRange} \{"Index out of range."\}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr const char * {\b kEmptyDeletion} \{"Cannot delete from empty object."\}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr const char * {\b kObjectFull} \{"Object full."\}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr const char * {\b kObjectEmpty} \{"Object empty."\}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr const char * {\b kPeekAtEmpty} \{"Cannot peek at empty objects."\}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Namespace for errors in the AlgLib library. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v kEmptyDeletion\:alglib::errors}
{\xe \v alglib::errors\:kEmptyDeletion}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* alglib::errors::kEmptyDeletion \{"Cannot delete from empty object."\}{\f2 [inline]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAAADU}
{\bkmkend AAAAAAAADU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 49} of file {\b constants.h}.}\par
}
{\xe \v kIndexOutOfRange\:alglib::errors}
{\xe \v alglib::errors\:kIndexOutOfRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* alglib::errors::kIndexOutOfRange \{"Index out of range."\}{\f2 [inline]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAAADV}
{\bkmkend AAAAAAAADV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 48} of file {\b constants.h}.}\par
}
{\xe \v kItemNotFound\:alglib::errors}
{\xe \v alglib::errors\:kItemNotFound}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* alglib::errors::kItemNotFound \{"Item not found."\}{\f2 [inline]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAAADW}
{\bkmkend AAAAAAAADW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 47} of file {\b constants.h}.}\par
}
{\xe \v kObjectEmpty\:alglib::errors}
{\xe \v alglib::errors\:kObjectEmpty}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* alglib::errors::kObjectEmpty \{"Object empty."\}{\f2 [inline]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAAADX}
{\bkmkend AAAAAAAADX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 51} of file {\b constants.h}.}\par
}
{\xe \v kObjectFull\:alglib::errors}
{\xe \v alglib::errors\:kObjectFull}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* alglib::errors::kObjectFull \{"Object full."\}{\f2 [inline]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAAADY}
{\bkmkend AAAAAAAADY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 50} of file {\b constants.h}.}\par
}
{\xe \v kPeekAtEmpty\:alglib::errors}
{\xe \v alglib::errors\:kPeekAtEmpty}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* alglib::errors::kPeekAtEmpty \{"Cannot peek at empty objects."\}{\f2 [inline]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAAADZ}
{\bkmkend AAAAAAAADZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 52} of file {\b constants.h}.}\par
}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Class Documentation{\tc \v Class Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
alglib::ArrayStack< T, capacity > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v alglib::ArrayStack< T, capacity >}
{\xe \v alglib::ArrayStack< T, capacity >}
{\bkmkstart AAAAAAAAAT}
{\bkmkend AAAAAAAAAT}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Template based stack implementation that uses an array as a base structure. It doesn't allocate memory on the heap, but it has a fixed capacity that has to be defined at compile time. }}\par
{
{\f2 #include <array_stack.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ArrayStack} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b ArrayStack} constructor. Only initializes the topIndex to -1. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Push} (T val)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Pushes a value to the top of the stack. Handles the topIndex and checks if the stack is full. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T {\b Pop} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Pops the value from the top of the stack. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T {\b Top} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Method that gets the value from the top of the stack without removing it. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b IsEmpty} () const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Method that checks if the stack is empty. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b IsFull} () const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Method that checks if the stack is full. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b Size} () const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Method that gets amount of elements in the stack. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b Capacity} () const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Method that gets the maximum capacity of the stack. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T, size_t capacity>\par
class alglib::ArrayStack< T, capacity >\par
}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Template based stack implementation that uses an array as a base structure. It doesn't allocate memory on the heap, but it has a fixed capacity that has to be defined at compile time. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Template Parameters\par}
\pard\plain \s80\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i T} \cell }{type of data stored in stack\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i capacity} \cell }{max capacity of stack (size of array)\cell }
{\row }
}
}{
Definition at line {\b 57} of file {\b array_stack.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v ArrayStack\:alglib::ArrayStack< T, capacity >}
{\xe \v alglib::ArrayStack< T, capacity >\:ArrayStack}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T, size_t capacity> {\b alglib::ArrayStack}< T, capacity >::ArrayStack ()}}
\par
{\bkmkstart AAAAAAAAAU}
{\bkmkend AAAAAAAAAU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b ArrayStack} constructor. Only initializes the topIndex to -1. }}\par
{
Definition at line {\b 87} of file {\b array_stack.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v Capacity\:alglib::ArrayStack< T, capacity >}
{\xe \v alglib::ArrayStack< T, capacity >\:Capacity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T, size_t capacity> size_t {\b alglib::ArrayStack}< T, capacity >::Capacity () const{\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAAV}
{\bkmkend AAAAAAAAAV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Method that gets the maximum capacity of the stack. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
maximum capacity of the stack.\par
}}}{
Definition at line {\b 159} of file {\b array_stack.h}.}\par
}
{\xe \v IsEmpty\:alglib::ArrayStack< T, capacity >}
{\xe \v alglib::ArrayStack< T, capacity >\:IsEmpty}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T, size_t capacity> bool {\b alglib::ArrayStack}< T, capacity >::IsEmpty () const{\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAAW}
{\bkmkend AAAAAAAAAW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Method that checks if the stack is empty. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if empty, false if not\par
}}}{
Definition at line {\b 132} of file {\b array_stack.h}.}\par
}
{\xe \v IsFull\:alglib::ArrayStack< T, capacity >}
{\xe \v alglib::ArrayStack< T, capacity >\:IsFull}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T, size_t capacity> bool {\b alglib::ArrayStack}< T, capacity >::IsFull () const{\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAAX}
{\bkmkend AAAAAAAAAX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Method that checks if the stack is full. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if stack is full, false if not.\par
}}}{
Definition at line {\b 141} of file {\b array_stack.h}.}\par
}
{\xe \v Pop\:alglib::ArrayStack< T, capacity >}
{\xe \v alglib::ArrayStack< T, capacity >\:Pop}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T, size_t capacity> T {\b alglib::ArrayStack}< T, capacity >::Pop ()}}
\par
{\bkmkstart AAAAAAAAAY}
{\bkmkend AAAAAAAAAY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Pops the value from the top of the stack. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
value that was on the top of the stack.\par
}}}{
Definition at line {\b 108} of file {\b array_stack.h}.}\par
}
{\xe \v Push\:alglib::ArrayStack< T, capacity >}
{\xe \v alglib::ArrayStack< T, capacity >\:Push}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T, size_t capacity> void {\b alglib::ArrayStack}< T, capacity >::Push (T val)}}
\par
{\bkmkstart AAAAAAAAAZ}
{\bkmkend AAAAAAAAAZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Pushes a value to the top of the stack. Handles the topIndex and checks if the stack is full. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i val} \cell }{value to be pushed.\cell }
{\row }
}
}{
Definition at line {\b 95} of file {\b array_stack.h}.}\par
}
{\xe \v Size\:alglib::ArrayStack< T, capacity >}
{\xe \v alglib::ArrayStack< T, capacity >\:Size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T, size_t capacity> size_t {\b alglib::ArrayStack}< T, capacity >::Size () const{\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAABA}
{\bkmkend AAAAAAAABA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Method that gets amount of elements in the stack. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
number of items in the stack.\par
}}}{
Definition at line {\b 150} of file {\b array_stack.h}.}\par
}
{\xe \v Top\:alglib::ArrayStack< T, capacity >}
{\xe \v alglib::ArrayStack< T, capacity >\:Top}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T, size_t capacity> T {\b alglib::ArrayStack}< T, capacity >::Top () const}}
\par
{\bkmkstart AAAAAAAABB}
{\bkmkend AAAAAAAABB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Method that gets the value from the top of the stack without removing it. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
vale that is on the top of the stack.\par
}}}{
Definition at line {\b 120} of file {\b array_stack.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Include/{\b array_stack.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
alglib::CircularQueue< T, capacity > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v alglib::CircularQueue< T, capacity >}
{\xe \v alglib::CircularQueue< T, capacity >}
{\bkmkstart AAAAAAAABC}
{\bkmkend AAAAAAAABC}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CircularQueue} class is a queue data structure implemented using an array. It doesn't allocate memory on the heap and has a fixed capacity that has to be defined at compile time. It uses a circular buffer to store elements. }}\par
{
{\f2 #include <circular_queue.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CircularQueue} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor for the {\b CircularQueue}. It initializes the front index and size to 0. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b IsEmpty} () const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Checks if the queue is empty by checking the size value. If size is 0, the queue is empty. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b IsFull} () const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Checks if the queue is full by comparing the size value to the capacity. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T {\b Dequeue} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the value from the front of the queue and moves the front index to the next element. If the queue is empty (size == 0), it throws a runtime error. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Enqueue} (T value)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds a new value to the rear of the queue. If the queue is full, it throws a runtime error. Size is increased by 1. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T {\b PeekFront} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the value from the front without moving the front index. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T {\b PeekRear} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets value from the rear of the queue without changing the size of the queue. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T, size_t capacity>\par
class alglib::CircularQueue< T, capacity >\par
}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CircularQueue} class is a queue data structure implemented using an array. It doesn't allocate memory on the heap and has a fixed capacity that has to be defined at compile time. It uses a circular buffer to store elements. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Template Parameters\par}
\pard\plain \s80\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i T} \cell }{type that will be stored in queue.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i capacity} \cell }{max capacity of queue.\cell }
{\row }
}
}{
Definition at line {\b 56} of file {\b circular_queue.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CircularQueue\:alglib::CircularQueue< T, capacity >}
{\xe \v alglib::CircularQueue< T, capacity >\:CircularQueue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T, size_t capacity> {\b alglib::CircularQueue}< T, capacity >::CircularQueue ()}}
\par
{\bkmkstart AAAAAAAABD}
{\bkmkend AAAAAAAABD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor for the {\b CircularQueue}. It initializes the front index and size to 0. }}\par
{
Definition at line {\b 91} of file {\b circular_queue.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v Dequeue\:alglib::CircularQueue< T, capacity >}
{\xe \v alglib::CircularQueue< T, capacity >\:Dequeue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T, size_t capacity> T {\b alglib::CircularQueue}< T, capacity >::Dequeue ()}}
\par
{\bkmkstart AAAAAAAABE}
{\bkmkend AAAAAAAABE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the value from the front of the queue and moves the front index to the next element. If the queue is empty (size == 0), it throws a runtime error. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
value of front element in queue.\par
}}}{
Definition at line {\b 118} of file {\b circular_queue.h}.}\par
}
{\xe \v Enqueue\:alglib::CircularQueue< T, capacity >}
{\xe \v alglib::CircularQueue< T, capacity >\:Enqueue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T, size_t capacity> void {\b alglib::CircularQueue}< T, capacity >::Enqueue (T value)}}
\par
{\bkmkstart AAAAAAAABF}
{\bkmkend AAAAAAAABF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds a new value to the rear of the queue. If the queue is full, it throws a runtime error. Size is increased by 1. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i value} \cell }{value to be inserted into queue.\cell }
{\row }
}
}{
Definition at line {\b 134} of file {\b circular_queue.h}.}\par
}
{\xe \v IsEmpty\:alglib::CircularQueue< T, capacity >}
{\xe \v alglib::CircularQueue< T, capacity >\:IsEmpty}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T, size_t capacity> bool {\b alglib::CircularQueue}< T, capacity >::IsEmpty () const{\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAABG}
{\bkmkend AAAAAAAABG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Checks if the queue is empty by checking the size value. If size is 0, the queue is empty. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if empty, false if not.\par
}}}{
Definition at line {\b 99} of file {\b circular_queue.h}.}\par
}
{\xe \v IsFull\:alglib::CircularQueue< T, capacity >}
{\xe \v alglib::CircularQueue< T, capacity >\:IsFull}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T, size_t capacity> bool {\b alglib::CircularQueue}< T, capacity >::IsFull () const{\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAABH}
{\bkmkend AAAAAAAABH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Checks if the queue is full by comparing the size value to the capacity. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if full, false if not\par
}}}{
Definition at line {\b 108} of file {\b circular_queue.h}.}\par
}
{\xe \v PeekFront\:alglib::CircularQueue< T, capacity >}
{\xe \v alglib::CircularQueue< T, capacity >\:PeekFront}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T, size_t capacity> T {\b alglib::CircularQueue}< T, capacity >::PeekFront () const}}
\par
{\bkmkstart AAAAAAAABI}
{\bkmkend AAAAAAAABI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the value from the front without moving the front index. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
value from the front of the queue.\par
}}}{
Definition at line {\b 148} of file {\b circular_queue.h}.}\par
}
{\xe \v PeekRear\:alglib::CircularQueue< T, capacity >}
{\xe \v alglib::CircularQueue< T, capacity >\:PeekRear}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T, size_t capacity> T {\b alglib::CircularQueue}< T, capacity >::PeekRear () const}}
\par
{\bkmkstart AAAAAAAABJ}
{\bkmkend AAAAAAAABJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets value from the rear of the queue without changing the size of the queue. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
value from the rear of the queue.\par
}}}{
Definition at line {\b 161} of file {\b circular_queue.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Include/{\b circular_queue.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
alglib::DoublyLinkedList< T > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v alglib::DoublyLinkedList< T >}
{\xe \v alglib::DoublyLinkedList< T >}
{\bkmkstart AAAAAAAABK}
{\bkmkend AAAAAAAABK}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Template based doubly linked list implementation. All nodes are dynamically allocated. }}\par
{
{\f2 #include <doubly_linked_list.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DoublyLinkedList} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor for the doubly linked list. It initializes the head and tail pointers to nullptr. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Traverse} (const std::function< void(T)> &visit_callback) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Method for traversing the doubly linked list. It starts at the head of the list and moves to the next node until the end of the list is reached. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b Size} () const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Method for calculating the number of elements in the doubly linked list. It starts at the head of the list and moves to the next node until the end of the list is reached. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b Find} (const T value) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Method for finding a value in the doubly linked list. It starts at the head of the list and moves to the next node until the end of the list is reached. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< T > {\b GetAsVector} () const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Method for converting the doubly linked list to a vector. It starts at the head of the list and moves to the next node until the end of the list is reached. It is used for testing purposes. Using it in production code is not recommended as it is simply missing the point of the doubly linked list. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b InsertAtBeginning} (const T data) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Method for inserting a new node at the beginning of the doubly linked list. It creates a new node with the given data and sets the next pointer of the new node to the head of the list. If the list is not empty, it sets the previous pointer of the head node to the new node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b InsertAtEnd} (const T data) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Method for inserting a new node at the end of the doubly linked list. It creates a new node with the given data and sets the next pointer of the last node in the list to the new node. If the list is empty, it sets the head pointer to the new node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b InsertAtPosition} (const uint32_t pos, const T data)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Method for inserting a new node at the given position in the doubly linked list. If the position is 0, insert at the beginning. If the position is equal to the size, insert at the end. Otherwise, link it into the middle. If pos is out of range, an exception is thrown. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b DeleteAtBeginning} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Method for deleting the first node in the doubly linked list. If the list is empty, an exception is thrown. If the list has only one node, the node is deleted and the head pointer is set to nullptr. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b DeleteAtEnd} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Method for deleting the last node in the doubly linked list. If the list is empty, an exception is thrown. If the list has only one node, the node is deleted and the head pointer is set to nullptr. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b DeleteAtPosition} (uint32_t pos)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Deletes the node at the given position in the doubly linked list. If the list is empty, an exception is thrown. If the position is out of range, an exception is thrown. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b IsEmpty} () const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Method for checking if the doubly linked list is empty. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~DoublyLinkedList} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor for the doubly linked list. It traverses the list and deletes each node in the list. It also deletes the tail pointer. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T>\par
class alglib::DoublyLinkedList< T >\par
}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Template based doubly linked list implementation. All nodes are dynamically allocated. \par
}{
Definition at line {\b 55} of file {\b doubly_linked_list.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v DoublyLinkedList\:alglib::DoublyLinkedList< T >}
{\xe \v alglib::DoublyLinkedList< T >\:DoublyLinkedList}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> {\b alglib::DoublyLinkedList}< T >::DoublyLinkedList ()}}
\par
{\bkmkstart AAAAAAAABL}
{\bkmkend AAAAAAAABL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor for the doubly linked list. It initializes the head and tail pointers to nullptr. }}\par
{
Definition at line {\b 117} of file {\b doubly_linked_list.h}.}\par
}
{\xe \v ~DoublyLinkedList\:alglib::DoublyLinkedList< T >}
{\xe \v alglib::DoublyLinkedList< T >\:~DoublyLinkedList}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> {\b alglib::DoublyLinkedList}< T >::~{\b DoublyLinkedList} ()}}
\par
{\bkmkstart AAAAAAAABM}
{\bkmkend AAAAAAAABM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor for the doubly linked list. It traverses the list and deletes each node in the list. It also deletes the tail pointer. }}\par
{
Definition at line {\b 355} of file {\b doubly_linked_list.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v DeleteAtBeginning\:alglib::DoublyLinkedList< T >}
{\xe \v alglib::DoublyLinkedList< T >\:DeleteAtBeginning}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> void {\b alglib::DoublyLinkedList}< T >::DeleteAtBeginning ()}}
\par
{\bkmkstart AAAAAAAABN}
{\bkmkend AAAAAAAABN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Method for deleting the first node in the doubly linked list. If the list is empty, an exception is thrown. If the list has only one node, the node is deleted and the head pointer is set to nullptr. }}\par
{
Definition at line {\b 274} of file {\b doubly_linked_list.h}.}\par
}
{\xe \v DeleteAtEnd\:alglib::DoublyLinkedList< T >}
{\xe \v alglib::DoublyLinkedList< T >\:DeleteAtEnd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> void {\b alglib::DoublyLinkedList}< T >::DeleteAtEnd ()}}
\par
{\bkmkstart AAAAAAAABO}
{\bkmkend AAAAAAAABO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Method for deleting the last node in the doubly linked list. If the list is empty, an exception is thrown. If the list has only one node, the node is deleted and the head pointer is set to nullptr. }}\par
{
Definition at line {\b 296} of file {\b doubly_linked_list.h}.}\par
}
{\xe \v DeleteAtPosition\:alglib::DoublyLinkedList< T >}
{\xe \v alglib::DoublyLinkedList< T >\:DeleteAtPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> void {\b alglib::DoublyLinkedList}< T >::DeleteAtPosition (uint32_t pos)}}
\par
{\bkmkstart AAAAAAAABP}
{\bkmkend AAAAAAAABP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Deletes the node at the given position in the doubly linked list. If the list is empty, an exception is thrown. If the position is out of range, an exception is thrown. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pos} \cell }{Position of node to delete (0 - first).\cell }
{\row }
}
}{
Definition at line {\b 319} of file {\b doubly_linked_list.h}.}\par
}
{\xe \v Find\:alglib::DoublyLinkedList< T >}
{\xe \v alglib::DoublyLinkedList< T >\:Find}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> size_t {\b alglib::DoublyLinkedList}< T >::Find (const T value) const}}
\par
{\bkmkstart AAAAAAAABQ}
{\bkmkend AAAAAAAABQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Method for finding a value in the doubly linked list. It starts at the head of the list and moves to the next node until the end of the list is reached. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i value} \cell }{Value that list is searched for.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Index of element if found. (0 - first).\par
}}}{
Definition at line {\b 157} of file {\b doubly_linked_list.h}.}\par
}
{\xe \v GetAsVector\:alglib::DoublyLinkedList< T >}
{\xe \v alglib::DoublyLinkedList< T >\:GetAsVector}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> std::vector< T > {\b alglib::DoublyLinkedList}< T >::GetAsVector () const{\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAABR}
{\bkmkend AAAAAAAABR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Method for converting the doubly linked list to a vector. It starts at the head of the list and moves to the next node until the end of the list is reached. It is used for testing purposes. Using it in production code is not recommended as it is simply missing the point of the doubly linked list. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Doubly linked list as vector.\par
}}}{
Definition at line {\b 181} of file {\b doubly_linked_list.h}.}\par
}
{\xe \v InsertAtBeginning\:alglib::DoublyLinkedList< T >}
{\xe \v alglib::DoublyLinkedList< T >\:InsertAtBeginning}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> void {\b alglib::DoublyLinkedList}< T >::InsertAtBeginning (const T data){\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAABS}
{\bkmkend AAAAAAAABS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Method for inserting a new node at the beginning of the doubly linked list. It creates a new node with the given data and sets the next pointer of the new node to the head of the list. If the list is not empty, it sets the previous pointer of the head node to the new node. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i data} \cell }{Value that will be inserted.\cell }
{\row }
}
}{
Definition at line {\b 200} of file {\b doubly_linked_list.h}.}\par
}
{\xe \v InsertAtEnd\:alglib::DoublyLinkedList< T >}
{\xe \v alglib::DoublyLinkedList< T >\:InsertAtEnd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> void {\b alglib::DoublyLinkedList}< T >::InsertAtEnd (const T data){\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAABT}
{\bkmkend AAAAAAAABT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Method for inserting a new node at the end of the doubly linked list. It creates a new node with the given data and sets the next pointer of the last node in the list to the new node. If the list is empty, it sets the head pointer to the new node. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i data} \cell }{Value that will be inserted.\cell }
{\row }
}
}{
Definition at line {\b 220} of file {\b doubly_linked_list.h}.}\par
}
{\xe \v InsertAtPosition\:alglib::DoublyLinkedList< T >}
{\xe \v alglib::DoublyLinkedList< T >\:InsertAtPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> void {\b alglib::DoublyLinkedList}< T >::InsertAtPosition (const uint32_t pos, const T data)}}
\par
{\bkmkstart AAAAAAAABU}
{\bkmkend AAAAAAAABU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Method for inserting a new node at the given position in the doubly linked list. If the position is 0, insert at the beginning. If the position is equal to the size, insert at the end. Otherwise, link it into the middle. If pos is out of range, an exception is thrown. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pos} \cell }{Position to insert the data (0-based index).\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i data} \cell }{Value that will be inserted.\cell }
{\row }
}
}{
Definition at line {\b 241} of file {\b doubly_linked_list.h}.}\par
}
{\xe \v IsEmpty\:alglib::DoublyLinkedList< T >}
{\xe \v alglib::DoublyLinkedList< T >\:IsEmpty}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> bool {\b alglib::DoublyLinkedList}< T >::IsEmpty () const{\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAABV}
{\bkmkend AAAAAAAABV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Method for checking if the doubly linked list is empty. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
True if the list is empty, false otherwise.\par
}}}{
Definition at line {\b 371} of file {\b doubly_linked_list.h}.}\par
}
{\xe \v Size\:alglib::DoublyLinkedList< T >}
{\xe \v alglib::DoublyLinkedList< T >\:Size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> size_t {\b alglib::DoublyLinkedList}< T >::Size () const{\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAABW}
{\bkmkend AAAAAAAABW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Method for calculating the number of elements in the doubly linked list. It starts at the head of the list and moves to the next node until the end of the list is reached. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Number of nodes in list.\par
}}}{
Definition at line {\b 140} of file {\b doubly_linked_list.h}.}\par
}
{\xe \v Traverse\:alglib::DoublyLinkedList< T >}
{\xe \v alglib::DoublyLinkedList< T >\:Traverse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> void {\b alglib::DoublyLinkedList}< T >::Traverse (const std::function< void(T)> & visit_callback){\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAABX}
{\bkmkend AAAAAAAABX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Method for traversing the doubly linked list. It starts at the head of the list and moves to the next node until the end of the list is reached. }}\par
{
Definition at line {\b 124} of file {\b doubly_linked_list.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Include/{\b doubly_linked_list.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
alglib::SinglyLinkedList< T > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v alglib::SinglyLinkedList< T >}
{\xe \v alglib::SinglyLinkedList< T >}
{\bkmkstart AAAAAAAABY}
{\bkmkend AAAAAAAABY}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Template based singly linked list implementation. All nodes are dynamically allocated. }}\par
{
{\f2 #include <singly_linked_list.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SinglyLinkedList} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor for the {\b SinglyLinkedList} structure. Initializes the head pointer to nullptr. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Traverse} (const std::function< void(T)> &visit_callback) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Method that traverses the singly linked list and prints the data of each node. Modifying the method to do something else with the data is straight forward and can be done by changing the body of the while loop. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b Size} () const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Method that calculates number of nodes in the singly linked list by traversing the list. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b Find} (T value) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Method that searches for a value in the singly linked list. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< T > {\b GetAsVector} () const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Method that converts the singly linked list to a vector. It is used for teseing purposes. Using it in production code is not recommended as it is simply missing the point of the singly linked list. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b InsertAtBeginning} (T value) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Method that inserts a new node at the beginning of the singly linked list by creating a new node and pointing it to the current head. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b InsertAtEnd} (T value) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Method that inserts a new node at the end of the singly linked list by traversing the list and adding the new node to the last node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b InsertAtPosition} (uint32_t pos, T value)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Method that inserts a new node at the given position in the singly linked list by traversing the list to find the possition and splicing the new node in. </summary {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pos} \cell }{Position for the new node (0 - first).\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i value} \cell }{Value for the new node.\cell }
{\row }
}
}{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b DeleteAtBeggining} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Method for deleting the first node in the singly linked list by pointing the head to the next node and deleting the first node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b DeleteAtEnd} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Method for deleting the last node in the singly linked list by traversing the list to the last node and deleting it. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b DeleteAtPosition} (uint32_t pos)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Method for deleting a node at a given position in the singly linked list by traversing the list to the given position and splicing the node out. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~SinglyLinkedList} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Method for deleting the singly linked list. It traverses the list and deletes each node as they are dynamically allocated. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T>\par
class alglib::SinglyLinkedList< T >\par
}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Template based singly linked list implementation. All nodes are dynamically allocated. \par
}{
Definition at line {\b 55} of file {\b singly_linked_list.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v SinglyLinkedList\:alglib::SinglyLinkedList< T >}
{\xe \v alglib::SinglyLinkedList< T >\:SinglyLinkedList}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> {\b alglib::SinglyLinkedList}< T >::SinglyLinkedList ()}}
\par
{\bkmkstart AAAAAAAABZ}
{\bkmkend AAAAAAAABZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor for the {\b SinglyLinkedList} structure. Initializes the head pointer to nullptr. }}\par
{
Definition at line {\b 122} of file {\b singly_linked_list.h}.}\par
}
{\xe \v ~SinglyLinkedList\:alglib::SinglyLinkedList< T >}
{\xe \v alglib::SinglyLinkedList< T >\:~SinglyLinkedList}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> {\b alglib::SinglyLinkedList}< T >::~{\b SinglyLinkedList} ()}}
\par
{\bkmkstart AAAAAAAACA}
{\bkmkend AAAAAAAACA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Method for deleting the singly linked list. It traverses the list and deletes each node as they are dynamically allocated. }}\par
{
Definition at line {\b 331} of file {\b singly_linked_list.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v DeleteAtBeggining\:alglib::SinglyLinkedList< T >}
{\xe \v alglib::SinglyLinkedList< T >\:DeleteAtBeggining}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> void {\b alglib::SinglyLinkedList}< T >::DeleteAtBeggining ()}}
\par
{\bkmkstart AAAAAAAACB}
{\bkmkend AAAAAAAACB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Method for deleting the first node in the singly linked list by pointing the head to the next node and deleting the first node. }}\par
{
Definition at line {\b 265} of file {\b singly_linked_list.h}.}\par
}
{\xe \v DeleteAtEnd\:alglib::SinglyLinkedList< T >}
{\xe \v alglib::SinglyLinkedList< T >\:DeleteAtEnd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> void {\b alglib::SinglyLinkedList}< T >::DeleteAtEnd ()}}
\par
{\bkmkstart AAAAAAAACC}
{\bkmkend AAAAAAAACC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Method for deleting the last node in the singly linked list by traversing the list to the last node and deleting it. }}\par
{
Definition at line {\b 283} of file {\b singly_linked_list.h}.}\par
}
{\xe \v DeleteAtPosition\:alglib::SinglyLinkedList< T >}
{\xe \v alglib::SinglyLinkedList< T >\:DeleteAtPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> void {\b alglib::SinglyLinkedList}< T >::DeleteAtPosition (uint32_t pos)}}
\par
{\bkmkstart AAAAAAAACD}
{\bkmkend AAAAAAAACD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Method for deleting a node at a given position in the singly linked list by traversing the list to the given position and splicing the node out. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pos} \cell }{Position of the node to delete (0 - first).\cell }
{\row }
}
}{
Definition at line {\b 303} of file {\b singly_linked_list.h}.}\par
}
{\xe \v Find\:alglib::SinglyLinkedList< T >}
{\xe \v alglib::SinglyLinkedList< T >\:Find}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> size_t {\b alglib::SinglyLinkedList}< T >::Find (T value) const}}
\par
{\bkmkstart AAAAAAAACE}
{\bkmkend AAAAAAAACE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Method that searches for a value in the singly linked list. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i value} \cell }{Value that the list will be searched for.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Index of first occurance of given value (0 = first).\par
}}}{
Definition at line {\b 162} of file {\b singly_linked_list.h}.}\par
}
{\xe \v GetAsVector\:alglib::SinglyLinkedList< T >}
{\xe \v alglib::SinglyLinkedList< T >\:GetAsVector}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> std::vector< T > {\b alglib::SinglyLinkedList}< T >::GetAsVector () const{\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAACF}
{\bkmkend AAAAAAAACF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Method that converts the singly linked list to a vector. It is used for teseing purposes. Using it in production code is not recommended as it is simply missing the point of the singly linked list. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
std::vector of nodes that are in structure.\par
}}}{
Definition at line {\b 186} of file {\b singly_linked_list.h}.}\par
}
{\xe \v InsertAtBeginning\:alglib::SinglyLinkedList< T >}
{\xe \v alglib::SinglyLinkedList< T >\:InsertAtBeginning}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> void {\b alglib::SinglyLinkedList}< T >::InsertAtBeginning (T value){\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAACG}
{\bkmkend AAAAAAAACG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Method that inserts a new node at the beginning of the singly linked list by creating a new node and pointing it to the current head. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i value} \cell }{Value for the new node.\cell }
{\row }
}
}{
Definition at line {\b 203} of file {\b singly_linked_list.h}.}\par
}
{\xe \v InsertAtEnd\:alglib::SinglyLinkedList< T >}
{\xe \v alglib::SinglyLinkedList< T >\:InsertAtEnd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> void {\b alglib::SinglyLinkedList}< T >::InsertAtEnd (T value){\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAACH}
{\bkmkend AAAAAAAACH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Method that inserts a new node at the end of the singly linked list by traversing the list and adding the new node to the last node. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i value} \cell }{Value for the new node.\cell }
{\row }
}
}{
Definition at line {\b 215} of file {\b singly_linked_list.h}.}\par
}
{\xe \v InsertAtPosition\:alglib::SinglyLinkedList< T >}
{\xe \v alglib::SinglyLinkedList< T >\:InsertAtPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> void {\b alglib::SinglyLinkedList}< T >::InsertAtPosition (uint32_t pos, T value)}}
\par
{\bkmkstart AAAAAAAACI}
{\bkmkend AAAAAAAACI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Method that inserts a new node at the given position in the singly linked list by traversing the list to find the possition and splicing the new node in. </summary {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pos} \cell }{Position for the new node (0 - first).\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i value} \cell }{Value for the new node.\cell }
{\row }
}
}}\par
{
Definition at line {\b 239} of file {\b singly_linked_list.h}.}\par
}
{\xe \v Size\:alglib::SinglyLinkedList< T >}
{\xe \v alglib::SinglyLinkedList< T >\:Size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> size_t {\b alglib::SinglyLinkedList}< T >::Size () const{\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAACJ}
{\bkmkend AAAAAAAACJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Method that calculates number of nodes in the singly linked list by traversing the list. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Number of nodes in structure as size_t.\par
}}}{
Definition at line {\b 146} of file {\b singly_linked_list.h}.}\par
}
{\xe \v Traverse\:alglib::SinglyLinkedList< T >}
{\xe \v alglib::SinglyLinkedList< T >\:Traverse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> void {\b alglib::SinglyLinkedList}< T >::Traverse (const std::function< void(T)> & visit_callback){\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAACK}
{\bkmkend AAAAAAAACK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Method that traverses the singly linked list and prints the data of each node. Modifying the method to do something else with the data is straight forward and can be done by changing the body of the while loop. }}\par
{
Definition at line {\b 131} of file {\b singly_linked_list.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Include/{\b singly_linked_list.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
alglib::SLLQueue< T > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v alglib::SLLQueue< T >}
{\xe \v alglib::SLLQueue< T >}
{\bkmkstart AAAAAAAACL}
{\bkmkend AAAAAAAACL}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b SLLQueue} class is a queue data structure implemented using singly linked list. It allocates nodes on the heap. Queue can grow dynamically. There is no limit to the amount of elements besides the memory available. }}\par
{
{\f2 #include <sll_queue.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SLLQueue} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b SLLQueue} constructor initializes the front and rear pointers to nullptr. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b IsEmpty} () const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Checks if the queue is empty by checking if the front pointer is nullptr. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T {\b Dequeue} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Pops the value from the front of the queue and returns it. The front pointer is then set to the next node in the queue. If the front pointer is nullptr, the rear pointer is also set to nullptr. It deletes the node from the front, so it cannot be accesed after the operation. if the queue is empty, it throws a runtime error. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Enqueue} (T value) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds a new node to the rear of the queue. If the queue is empty, the front and rear pointers are set to the new node. Otherwise, the new node is set as the next node of the rear pointer and the rear pointer is set to the new node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T {\b PeekFront} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the value from the front of the queue without removing it. If the queue is empty, it throws a runtime error. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T {\b PeekRear} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the value from the rear of the queue without removing it. If the queue is empty, it throws a runtime error. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~SLLQueue} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Deletes all nodes from the queue. It starts from the front and deletes all nodes until the rear. It then deletes the rear node. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T>\par
class alglib::SLLQueue< T >\par
}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b SLLQueue} class is a queue data structure implemented using singly linked list. It allocates nodes on the heap. Queue can grow dynamically. There is no limit to the amount of elements besides the memory available. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Template Parameters\par}
\pard\plain \s80\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i T} \cell }{type that will be stored in queue.\cell }
{\row }
}
}{
Definition at line {\b 51} of file {\b sll_queue.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v SLLQueue\:alglib::SLLQueue< T >}
{\xe \v alglib::SLLQueue< T >\:SLLQueue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> {\b alglib::SLLQueue}< T >::SLLQueue ()}}
\par
{\bkmkstart AAAAAAAACM}
{\bkmkend AAAAAAAACM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b SLLQueue} constructor initializes the front and rear pointers to nullptr. }}\par
{
Definition at line {\b 100} of file {\b sll_queue.h}.}\par
}
{\xe \v ~SLLQueue\:alglib::SLLQueue< T >}
{\xe \v alglib::SLLQueue< T >\:~SLLQueue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> {\b alglib::SLLQueue}< T >::~{\b SLLQueue} ()}}
\par
{\bkmkstart AAAAAAAACN}
{\bkmkend AAAAAAAACN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Deletes all nodes from the queue. It starts from the front and deletes all nodes until the rear. It then deletes the rear node. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Template Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i T} \cell }{\cell }
{\row }
}
}{
Definition at line {\b 184} of file {\b sll_queue.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v Dequeue\:alglib::SLLQueue< T >}
{\xe \v alglib::SLLQueue< T >\:Dequeue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> T {\b alglib::SLLQueue}< T >::Dequeue ()}}
\par
{\bkmkstart AAAAAAAACO}
{\bkmkend AAAAAAAACO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Pops the value from the front of the queue and returns it. The front pointer is then set to the next node in the queue. If the front pointer is nullptr, the rear pointer is also set to nullptr. It deletes the node from the front, so it cannot be accesed after the operation. if the queue is empty, it throws a runtime error. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
\par
}}}{
Definition at line {\b 120} of file {\b sll_queue.h}.}\par
}
{\xe \v Enqueue\:alglib::SLLQueue< T >}
{\xe \v alglib::SLLQueue< T >\:Enqueue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> void {\b alglib::SLLQueue}< T >::Enqueue (T value){\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAACP}
{\bkmkend AAAAAAAACP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds a new node to the rear of the queue. If the queue is empty, the front and rear pointers are set to the new node. Otherwise, the new node is set as the next node of the rear pointer and the rear pointer is set to the new node. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i value} \cell }{value to be inserted into queue.\cell }
{\row }
}
}{
Definition at line {\b 141} of file {\b sll_queue.h}.}\par
}
{\xe \v IsEmpty\:alglib::SLLQueue< T >}
{\xe \v alglib::SLLQueue< T >\:IsEmpty}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> bool {\b alglib::SLLQueue}< T >::IsEmpty () const{\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAACQ}
{\bkmkend AAAAAAAACQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Checks if the queue is empty by checking if the front pointer is nullptr. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if empty, false if not.\par
}}}{
Definition at line {\b 107} of file {\b sll_queue.h}.}\par
}
{\xe \v PeekFront\:alglib::SLLQueue< T >}
{\xe \v alglib::SLLQueue< T >\:PeekFront}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> T {\b alglib::SLLQueue}< T >::PeekFront () const}}
\par
{\bkmkstart AAAAAAAACR}
{\bkmkend AAAAAAAACR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the value from the front of the queue without removing it. If the queue is empty, it throws a runtime error. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Template Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i T} \cell }{\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
\par
}}}{
Definition at line {\b 157} of file {\b sll_queue.h}.}\par
}
{\xe \v PeekRear\:alglib::SLLQueue< T >}
{\xe \v alglib::SLLQueue< T >\:PeekRear}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> T {\b alglib::SLLQueue}< T >::PeekRear () const}}
\par
{\bkmkstart AAAAAAAACS}
{\bkmkend AAAAAAAACS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the value from the rear of the queue without removing it. If the queue is empty, it throws a runtime error. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Template Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i T} \cell }{\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
\par
}}}{
Definition at line {\b 171} of file {\b sll_queue.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Include/{\b sll_queue.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
alglib::SLLStack< T > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v alglib::SLLStack< T >}
{\xe \v alglib::SLLStack< T >}
{\bkmkstart AAAAAAAACT}
{\bkmkend AAAAAAAACT}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b SLLStack} is a stack implementation that uses a singly linked list as a base structure. It allocates memory on the heap, so the stack can grow dynamically. }}\par
{
{\f2 #include <sll_stack.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SLLStack} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor for the {\b SLLStack}. Initializes the top pointer to nullptr. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Push} (T val) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Pushes a value to the top of the stack by creating a new node on the heap and setting the next pointer to the current top. The top pointer is then set to the new node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T {\b Pop} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Pops the value from the top of the stack and returns it. The top node is deleted. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T {\b Top} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns value from the top of the stack without removing it. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b IsEmpty} () const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Checks if the stack is empty by checking if the top pointer is nullptr. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b Size} () const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calculates size of the stack by traversing the list and counting the nodes. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~SLLStack} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes all nodes from the stack by traversing the list and deleting each. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T>\par
class alglib::SLLStack< T >\par
}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b SLLStack} is a stack implementation that uses a singly linked list as a base structure. It allocates memory on the heap, so the stack can grow dynamically. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Template Parameters\par}
\pard\plain \s80\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i T} \cell }{type of data stored on the stack.\cell }
{\row }
}
}{
Definition at line {\b 54} of file {\b sll_stack.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v SLLStack\:alglib::SLLStack< T >}
{\xe \v alglib::SLLStack< T >\:SLLStack}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> {\b alglib::SLLStack}< T >::SLLStack ()}}
\par
{\bkmkstart AAAAAAAACU}
{\bkmkend AAAAAAAACU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor for the {\b SLLStack}. Initializes the top pointer to nullptr. }}\par
{
Definition at line {\b 97} of file {\b sll_stack.h}.}\par
}
{\xe \v ~SLLStack\:alglib::SLLStack< T >}
{\xe \v alglib::SLLStack< T >\:~SLLStack}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> {\b alglib::SLLStack}< T >::~{\b SLLStack} ()}}
\par
{\bkmkstart AAAAAAAACV}
{\bkmkend AAAAAAAACV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes all nodes from the stack by traversing the list and deleting each. }}\par
{
Definition at line {\b 169} of file {\b sll_stack.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v IsEmpty\:alglib::SLLStack< T >}
{\xe \v alglib::SLLStack< T >\:IsEmpty}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> bool {\b alglib::SLLStack}< T >::IsEmpty () const{\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAACW}
{\bkmkend AAAAAAAACW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Checks if the stack is empty by checking if the top pointer is nullptr. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if empty, false if not.\par
}}}{
Definition at line {\b 146} of file {\b sll_stack.h}.}\par
}
{\xe \v Pop\:alglib::SLLStack< T >}
{\xe \v alglib::SLLStack< T >\:Pop}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> T {\b alglib::SLLStack}< T >::Pop ()}}
\par
{\bkmkstart AAAAAAAACX}
{\bkmkend AAAAAAAACX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Pops the value from the top of the stack and returns it. The top node is deleted. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
value on top of the stack.\par
}}}{
Definition at line {\b 118} of file {\b sll_stack.h}.}\par
}
{\xe \v Push\:alglib::SLLStack< T >}
{\xe \v alglib::SLLStack< T >\:Push}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> void {\b alglib::SLLStack}< T >::Push (T val){\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAACY}
{\bkmkend AAAAAAAACY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Pushes a value to the top of the stack by creating a new node on the heap and setting the next pointer to the current top. The top pointer is then set to the new node. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i val} \cell }{value to be pushed on the stack.\cell }
{\row }
}
}{
Definition at line {\b 106} of file {\b sll_stack.h}.}\par
}
{\xe \v Size\:alglib::SLLStack< T >}
{\xe \v alglib::SLLStack< T >\:Size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> size_t {\b alglib::SLLStack}< T >::Size () const{\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAACZ}
{\bkmkend AAAAAAAACZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calculates size of the stack by traversing the list and counting the nodes. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
amount values on stack.\par
}}}{
Definition at line {\b 155} of file {\b sll_stack.h}.}\par
}
{\xe \v Top\:alglib::SLLStack< T >}
{\xe \v alglib::SLLStack< T >\:Top}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> T {\b alglib::SLLStack}< T >::Top () const}}
\par
{\bkmkstart AAAAAAAADA}
{\bkmkend AAAAAAAADA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns value from the top of the stack without removing it. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
value on top of the stack.\par
}}}{
Definition at line {\b 134} of file {\b sll_stack.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Include/{\b sll_stack.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
alglib::Vector< T > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v alglib::Vector< T >}
{\xe \v alglib::Vector< T >}
{\bkmkstart AAAAAAAADB}
{\bkmkend AAAAAAAADB}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Template based vector implementation that uses an array as a base structure. It allocates memory on the heap, and it can grow dynamically. Capacity doubles every time the size exceeds current capacity. }}\par
{
{\f2 #include <vector.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Vector} () noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
No argument constructor for the vector class. It initializes the vector with default values. It allocates memory for 4 elements. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Vector} (size_t elements) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor that initializes the vector with a given number of elements. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Vector} (size_t elements, const T &value) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor that initializes the vector to a given number of elements with a given value. All elements will be set to the given value. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Push} (const T &value) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds a new element to the end of the vector. If the size exceeds the capacity, the capacity is doubled. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Insert} (const T &value, size_t index)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inserts a new element at a given index. If the index is out of range, an exception is thrown. If the size exceeds the capacity, the capacity is doubled just like in the Push method. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T & {\b Pop} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the last element of the vector and removes it from the vector by decrementing the size. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T & {\b At} (size_t index)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the element at a given index. If the index is out of range, an exception is thrown. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const T & {\b At} (size_t index) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the element at a given index. If the index is out of range, an exception is thrown. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b Size} () const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return amount of elements in the vector. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b Capacity} () const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns current maximum capacity of the vector. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Resize} (size_t size)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Modifies the size of the vector. If the new size is smaller than the current size, the vector is truncated. If the new size is larger than the current size, the vector is extended. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ShrinkToFit} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Shrinks the capacity of the vector to the current size by reallocating memory with the size of the vector. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T & {\b Front} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the first element of the vector. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const T & {\b Front} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the first element of the vector. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T & {\b Back} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the last element of the vector. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const T & {\b Back} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the last element of the vector. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~Vector} () noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Deletes the vector and deallocates memory. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T>\par
class alglib::Vector< T >\par
}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Template based vector implementation that uses an array as a base structure. It allocates memory on the heap, and it can grow dynamically. Capacity doubles every time the size exceeds current capacity. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Template Parameters\par}
\pard\plain \s80\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i T} \cell }{type of data stored in vector.\cell }
{\row }
}
}{
Definition at line {\b 52} of file {\b vector.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Vector\:alglib::Vector< T >}
{\xe \v alglib::Vector< T >\:Vector}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> {\b alglib::Vector}< T >::Vector (){\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAADC}
{\bkmkend AAAAAAAADC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
No argument constructor for the vector class. It initializes the vector with default values. It allocates memory for 4 elements. }}\par
{
Definition at line {\b 109} of file {\b vector.h}.}\par
}
{\xe \v Vector\:alglib::Vector< T >}
{\xe \v alglib::Vector< T >\:Vector}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> {\b alglib::Vector}< T >::Vector (size_t elements){\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAADD}
{\bkmkend AAAAAAAADD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor that initializes the vector with a given number of elements. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i elements} \cell }{amount of elements that will be initially allocated.\cell }
{\row }
}
}{
Definition at line {\b 119} of file {\b vector.h}.}\par
}
{\xe \v Vector\:alglib::Vector< T >}
{\xe \v alglib::Vector< T >\:Vector}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> {\b alglib::Vector}< T >::Vector (size_t elements, const T & value){\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAADE}
{\bkmkend AAAAAAAADE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor that initializes the vector to a given number of elements with a given value. All elements will be set to the given value. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i elements} \cell }{amount of elements that will be initially allocated. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i value} \cell }{value that all the elements will be initialised to.\cell }
{\row }
}
}{
Definition at line {\b 133} of file {\b vector.h}.}\par
}
{\xe \v ~Vector\:alglib::Vector< T >}
{\xe \v alglib::Vector< T >\:~Vector}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> {\b alglib::Vector}< T >::~{\b Vector} (){\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAADF}
{\bkmkend AAAAAAAADF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Deletes the vector and deallocates memory. }}\par
{
Definition at line {\b 292} of file {\b vector.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v At\:alglib::Vector< T >}
{\xe \v alglib::Vector< T >\:At}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> T & {\b alglib::Vector}< T >::At (size_t index)}}
\par
{\bkmkstart AAAAAAAADG}
{\bkmkend AAAAAAAADG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the element at a given index. If the index is out of range, an exception is thrown. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i index} \cell }{index of element to return.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
element at a given index.\par
}}}{
Definition at line {\b 193} of file {\b vector.h}.}\par
}
{\xe \v At\:alglib::Vector< T >}
{\xe \v alglib::Vector< T >\:At}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> const T & {\b alglib::Vector}< T >::At (size_t index) const}}
\par
{\bkmkstart AAAAAAAADH}
{\bkmkend AAAAAAAADH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the element at a given index. If the index is out of range, an exception is thrown. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i index} \cell }{index of element to return.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
element at a given index.\par
}}}{
Definition at line {\b 207} of file {\b vector.h}.}\par
}
{\xe \v Back\:alglib::Vector< T >}
{\xe \v alglib::Vector< T >\:Back}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> T & {\b alglib::Vector}< T >::Back ()}}
\par
{\bkmkstart AAAAAAAADI}
{\bkmkend AAAAAAAADI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the last element of the vector. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
last element of the vector.\par
}}}{
Definition at line {\b 275} of file {\b vector.h}.}\par
}
{\xe \v Back\:alglib::Vector< T >}
{\xe \v alglib::Vector< T >\:Back}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> const T & {\b alglib::Vector}< T >::Back () const}}
\par
{\bkmkstart AAAAAAAADJ}
{\bkmkend AAAAAAAADJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the last element of the vector. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
last element of the vector.\par
}}}{
Definition at line {\b 284} of file {\b vector.h}.}\par
}
{\xe \v Capacity\:alglib::Vector< T >}
{\xe \v alglib::Vector< T >\:Capacity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> size_t {\b alglib::Vector}< T >::Capacity () const{\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAADK}
{\bkmkend AAAAAAAADK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns current maximum capacity of the vector. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
current maximum capacity of the vector.\par
}}}{
Definition at line {\b 228} of file {\b vector.h}.}\par
}
{\xe \v Front\:alglib::Vector< T >}
{\xe \v alglib::Vector< T >\:Front}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> T & {\b alglib::Vector}< T >::Front ()}}
\par
{\bkmkstart AAAAAAAADL}
{\bkmkend AAAAAAAADL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the first element of the vector. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
first element of the vector.\par
}}}{
Definition at line {\b 257} of file {\b vector.h}.}\par
}
{\xe \v Front\:alglib::Vector< T >}
{\xe \v alglib::Vector< T >\:Front}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> const T & {\b alglib::Vector}< T >::Front () const}}
\par
{\bkmkstart AAAAAAAADM}
{\bkmkend AAAAAAAADM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the first element of the vector. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
first element of the vector.\par
}}}{
Definition at line {\b 266} of file {\b vector.h}.}\par
}
{\xe \v Insert\:alglib::Vector< T >}
{\xe \v alglib::Vector< T >\:Insert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> void {\b alglib::Vector}< T >::Insert (const T & value, size_t index)}}
\par
{\bkmkstart AAAAAAAADN}
{\bkmkend AAAAAAAADN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inserts a new element at a given index. If the index is out of range, an exception is thrown. If the size exceeds the capacity, the capacity is doubled just like in the Push method. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i value} \cell }{value to be inserted.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i index} \cell }{inserting position.\cell }
{\row }
}
}{
Definition at line {\b 162} of file {\b vector.h}.}\par
}
{\xe \v Pop\:alglib::Vector< T >}
{\xe \v alglib::Vector< T >\:Pop}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> T & {\b alglib::Vector}< T >::Pop ()}}
\par
{\bkmkstart AAAAAAAADO}
{\bkmkend AAAAAAAADO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the last element of the vector and removes it from the vector by decrementing the size. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
last element of the vector.\par
}}}{
Definition at line {\b 182} of file {\b vector.h}.}\par
}
{\xe \v Push\:alglib::Vector< T >}
{\xe \v alglib::Vector< T >\:Push}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> void {\b alglib::Vector}< T >::Push (const T & value){\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAADP}
{\bkmkend AAAAAAAADP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds a new element to the end of the vector. If the size exceeds the capacity, the capacity is doubled. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i value} \cell }{value to be added.\cell }
{\row }
}
}{
Definition at line {\b 147} of file {\b vector.h}.}\par
}
{\xe \v Resize\:alglib::Vector< T >}
{\xe \v alglib::Vector< T >\:Resize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> void {\b alglib::Vector}< T >::Resize (size_t size)}}
\par
{\bkmkstart AAAAAAAADQ}
{\bkmkend AAAAAAAADQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Modifies the size of the vector. If the new size is smaller than the current size, the vector is truncated. If the new size is larger than the current size, the vector is extended. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i size} \cell }{new size.\cell }
{\row }
}
}{
Definition at line {\b 239} of file {\b vector.h}.}\par
}
{\xe \v ShrinkToFit\:alglib::Vector< T >}
{\xe \v alglib::Vector< T >\:ShrinkToFit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> void {\b alglib::Vector}< T >::ShrinkToFit ()}}
\par
{\bkmkstart AAAAAAAADR}
{\bkmkend AAAAAAAADR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Shrinks the capacity of the vector to the current size by reallocating memory with the size of the vector. }}\par
{
Definition at line {\b 248} of file {\b vector.h}.}\par
}
{\xe \v Size\:alglib::Vector< T >}
{\xe \v alglib::Vector< T >\:Size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> size_t {\b alglib::Vector}< T >::Size () const{\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAADS}
{\bkmkend AAAAAAAADS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return amount of elements in the vector. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
amount of elements in the vector.\par
}}}{
Definition at line {\b 219} of file {\b vector.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Include/{\b vector.h}\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Documentation{\tc \v File Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Include/alg_lib.h File Reference\par \pard\plain 
{\tc\tcl2 \v Include/alg_lib.h}
{\xe \v Include/alg_lib.h}
{\bkmkstart AAAAAAAAAJ}
{\bkmkend AAAAAAAAAJ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "singly_linked_list.h"}\par
{\f2 #include "doubly_linked_list.h"}\par
{\f2 #include "constants.h"}\par
{\f2 #include "array_stack.h"}\par
{\f2 #include "sll_stack.h"}\par
{\f2 #include "circular_queue.h"}\par
{\f2 #include "sll_queue.h"}\par
{\f2 #include "adj_mat_graph.h"}\par
{\f2 #include "vector.h"}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
alg_lib.h\par \pard\plain 
{\tc\tcl2 \v Include/alg_lib.h}
{\xe \v Include/alg_lib.h}
{\bkmkstart AAAAAAAAAA}
{\bkmkend AAAAAAAAAA}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //*****************************************************************************}\par
00002 {\cf20 // The MIT License (MIT)}\par
00003 {\cf20 //}\par
00004 {\cf20 // Copyright \'A9 2024 Piotr Walczak}\par
00005 {\cf20 //}\par
00006 {\cf20 // Permission is hereby granted, free of charge, to any person obtaining a copy}\par
00007 {\cf20 // of this software and associated documentation files (the \'93Software\'94), to}\par
00008 {\cf20 // deal in the Software without restriction, including without limitation the}\par
00009 {\cf20 // rights to use, copy, modify, merge, publish, distribute, sublicense, and/or}\par
00010 {\cf20 // sell copies of the Software, and to permit persons to whom the Software is}\par
00011 {\cf20 // furnished to do so, subject to the following conditions:}\par
00012 {\cf20 //}\par
00013 {\cf20 // The above copyright notice and this permission notice shall be included in}\par
00014 {\cf20 // all copies or substantial portions of the Software.}\par
00015 {\cf20 //}\par
00016 {\cf20 // THE SOFTWARE IS PROVIDED \'93AS IS\'94, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR}\par
00017 {\cf20 // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,}\par
00018 {\cf20 // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL}\par
00019 {\cf20 // THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER}\par
00020 {\cf20 // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING}\par
00021 {\cf20 // FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS}\par
00022 {\cf20 // IN THE SOFTWARE.}\par
00023 {\cf20 //*****************************************************************************}\par
00024 \par
00025 {\cf20 //*****************************************************************************}\par
00026 {\cf20 // File: array_stack.h}\par
00027 {\cf20 //}\par
00028 {\cf20 // This file imports whole library at once for easier use.}\par
00029 {\cf20 //*****************************************************************************}\par
00030 \par
00031 {\cf21 #ifndef ALGLIB_INCLUDE_ALGLIB_H_}\par
00032 {\cf21 #define ALGLIB_INCLUDE_ALGLIB_H_}\par
00033 \par
00034 {\cf21 #include "singly_linked_list.h"}\par
00035 {\cf21 #include "doubly_linked_list.h"}\par
00036 {\cf21 #include "constants.h"}\par
00037 {\cf21 #include "array_stack.h"}\par
00038 {\cf21 #include "sll_stack.h"}\par
00039 {\cf21 #include "circular_queue.h"}\par
00040 {\cf21 #include "sll_queue.h"}\par
00041 {\cf21 #include "adj_mat_graph.h"}\par
00042 {\cf21 #include "vector.h"}\par
00043 \par
00044 {\cf21 #endif }{\cf20 // ALGLIB_INCLUDE_ALGLIB_H_}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Include/array_stack.h File Reference\par \pard\plain 
{\tc\tcl2 \v Include/array_stack.h}
{\xe \v Include/array_stack.h}
{\bkmkstart AAAAAAAAAK}
{\bkmkend AAAAAAAAAK}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <array>}\par
{\f2 #include <stdexcept>}\par
{\f2 #include "constants.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b alglib::ArrayStack< T, capacity >}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Template based stack implementation that uses an array as a base structure. It doesn't allocate memory on the heap, but it has a fixed capacity that has to be defined at compile time. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b alglib}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default namespace for the AlgLib library. }}\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
array_stack.h\par \pard\plain 
{\tc\tcl2 \v Include/array_stack.h}
{\xe \v Include/array_stack.h}
{\bkmkstart AAAAAAAAAB}
{\bkmkend AAAAAAAAAB}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //*****************************************************************************}\par
00002 {\cf20 // The MIT License (MIT)}\par
00003 {\cf20 //}\par
00004 {\cf20 // Copyright \'A9 2024 Piotr Walczak}\par
00005 {\cf20 //}\par
00006 {\cf20 // Permission is hereby granted, free of charge, to any person obtaining a copy}\par
00007 {\cf20 // of this software and associated documentation files (the \'93Software\'94), to}\par
00008 {\cf20 // deal in the Software without restriction, including without limitation the}\par
00009 {\cf20 // rights to use, copy, modify, merge, publish, distribute, sublicense, and/or}\par
00010 {\cf20 // sell copies of the Software, and to permit persons to whom the Software is}\par
00011 {\cf20 // furnished to do so, subject to the following conditions:}\par
00012 {\cf20 //}\par
00013 {\cf20 // The above copyright notice and this permission notice shall be included in}\par
00014 {\cf20 // all copies or substantial portions of the Software.}\par
00015 {\cf20 //}\par
00016 {\cf20 // THE SOFTWARE IS PROVIDED \'93AS IS\'94, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR}\par
00017 {\cf20 // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,}\par
00018 {\cf20 // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL}\par
00019 {\cf20 // THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER}\par
00020 {\cf20 // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING}\par
00021 {\cf20 // FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS}\par
00022 {\cf20 // IN THE SOFTWARE.}\par
00023 {\cf20 //*****************************************************************************}\par
00024 \par
00025 {\cf20 //*****************************************************************************}\par
00026 {\cf20 // File: array_stack.h}\par
00027 {\cf20 //}\par
00028 {\cf20 // This file contains the implementation of the ArrayStack class. Implementation}\par
00029 {\cf20 // is based on templates, so the class can be used with any type. ArrayStack}\par
00030 {\cf20 // is a stack implementation that uses an array as a base structure. It doesn't}\par
00031 {\cf20 // allocate memory on the heap, so it is faster than the implementation that}\par
00032 {\cf20 // can grow dynamically. The class is implemented in the alglib namespace.}\par
00033 {\cf20 //*****************************************************************************}\par
00034 \par
00035 {\cf21 #ifndef ALGLIB_INCLUDE_ARRAYSTACK_H_}\par
00036 {\cf21 #define ALGLIB_INCLUDE_ARRAYSTACK_H_}\par
00037 \par
00038 {\cf21 #include <array>}\par
00039 {\cf21 #include <stdexcept>}\par
00040 \par
00041 {\cf21 #include "constants.h"}\par
00042 \par
00046 {\cf17 namespace }alglib \{\par
00047 \par
00056 {\cf17 template} <{\cf17 typename} T, {\cf18 size_t} capacity>\par
00057 {\cf17 class }ArrayStack \{\par
00058  {\cf17 public}:\par
00059   {\cf20 // Constructor for the ArrayStack.}\par
00060   ArrayStack();\par
00061 \par
00062   {\cf20 // Methods for manipulating the stack.}\par
00063   {\cf18 void} Push(T val);\par
00064   T Pop();\par
00065   T Top() {\cf17 const};\par
00066   {\cf18 bool} IsEmpty() {\cf17 const} {\cf17 noexcept};\par
00067   {\cf18 bool} IsFull() {\cf17 const} {\cf17 noexcept};\par
00068   {\cf18 size_t} Size() {\cf17 const} {\cf17 noexcept};\par
00069   {\cf18 size_t} Capacity() {\cf17 const} {\cf17 noexcept};\par
00070 \par
00071  {\cf17 private}:\par
00075   std::array<T, capacity> data;\par
00076 \par
00080   {\cf18 int} topIndex;\par
00081 \};\par
00082 \par
00086 {\cf17 template} <{\cf17 typename} T, {\cf18 size_t} capacity>\par
00087 ArrayStack<T, capacity>::ArrayStack() : topIndex(-1), data() \{\}\par
00088 \par
00094 {\cf17 template} <{\cf17 typename} T, {\cf18 size_t} capacity>\par
00095 {\cf18 void} ArrayStack<T, capacity>::Push(T val) \{\par
00096   topIndex++;\par
00097   {\cf19 if} (topIndex >= capacity) \{\par
00098     {\cf19 throw} std::runtime_error(errors::kObjectFull);\par
00099   \}\par
00100   data[topIndex] = val;\par
00101 \}\par
00102 \par
00107 {\cf17 template} <{\cf17 typename} T, {\cf18 size_t} capacity>\par
00108 T ArrayStack<T, capacity>::Pop() \{\par
00109   {\cf19 if} (topIndex < 0) \{\par
00110     {\cf19 throw} std::runtime_error(errors::kEmptyDeletion);\par
00111   \}\par
00112   {\cf19 return} data.at(topIndex--);\par
00113 \}\par
00114 \par
00119 {\cf17 template} <{\cf17 typename} T, {\cf18 size_t} capacity>\par
00120 T ArrayStack<T, capacity>::Top(){\cf17  const }\{\par
00121   {\cf19 if} (IsEmpty()) \{\par
00122     {\cf19 throw} std::runtime_error(errors::kPeekAtEmpty);\par
00123   \}\par
00124   {\cf19 return} data.at(topIndex);\par
00125 \}\par
00126 \par
00131 {\cf17 template} <{\cf17 typename} T, {\cf18 size_t} capacity>\par
00132 {\cf18 bool} ArrayStack<T, capacity>::IsEmpty() const noexcept \{\par
00133   {\cf19 return} topIndex < 0;\par
00134 \}\par
00135 \par
00140 {\cf17 template} <{\cf17 typename} T, {\cf18 size_t} capacity>  \par
00141 {\cf18 bool} ArrayStack<T, capacity>::IsFull() const noexcept \{  \par
00142  {\cf19 return} topIndex == capacity - 1;  \par
00143 \}\par
00144 \par
00149 {\cf17 template} <{\cf17 typename} T, {\cf18 size_t} capacity>\par
00150 {\cf18 size_t} ArrayStack<T, capacity>::Size() const noexcept \{\par
00151   {\cf19 return} topIndex + 1;\par
00152 \}\par
00153 \par
00158 {\cf17 template} <{\cf17 typename} T, {\cf18 size_t} capacity>\par
00159 {\cf18 size_t} ArrayStack<T, capacity>::Capacity() const noexcept \{\par
00160   {\cf19 return} capacity;\par
00161 \}\par
00162 \par
00163 \}  {\cf20 // namespace alglib}\par
00164 \par
00165 {\cf21 #endif  }{\cf20 // ALGLIB_INCLUDE_ARRAYSTACK_H_}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Include/circular_queue.h File Reference\par \pard\plain 
{\tc\tcl2 \v Include/circular_queue.h}
{\xe \v Include/circular_queue.h}
{\bkmkstart AAAAAAAAAL}
{\bkmkend AAAAAAAAAL}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <array>}\par
{\f2 #include <stdexcept>}\par
{\f2 #include "constants.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b alglib::CircularQueue< T, capacity >}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CircularQueue} class is a queue data structure implemented using an array. It doesn't allocate memory on the heap and has a fixed capacity that has to be defined at compile time. It uses a circular buffer to store elements. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b alglib}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default namespace for the AlgLib library. }}\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
circular_queue.h\par \pard\plain 
{\tc\tcl2 \v Include/circular_queue.h}
{\xe \v Include/circular_queue.h}
{\bkmkstart AAAAAAAAAC}
{\bkmkend AAAAAAAAAC}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //*****************************************************************************}\par
00002 {\cf20 // The MIT License (MIT)}\par
00003 {\cf20 //}\par
00004 {\cf20 // Copyright \'A9 2024 Piotr Walczak}\par
00005 {\cf20 //}\par
00006 {\cf20 // Permission is hereby granted, free of charge, to any person obtaining a copy}\par
00007 {\cf20 // of this software and associated documentation files (the \'93Software\'94), to}\par
00008 {\cf20 // deal in the Software without restriction, including without limitation the}\par
00009 {\cf20 // rights to use, copy, modify, merge, publish, distribute, sublicense, and/or}\par
00010 {\cf20 // sell copies of the Software, and to permit persons to whom the Software is}\par
00011 {\cf20 // furnished to do so, subject to the following conditions:}\par
00012 {\cf20 //}\par
00013 {\cf20 // The above copyright notice and this permission notice shall be included in}\par
00014 {\cf20 // all copies or substantial portions of the Software.}\par
00015 {\cf20 //}\par
00016 {\cf20 // THE SOFTWARE IS PROVIDED \'93AS IS\'94, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR}\par
00017 {\cf20 // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,}\par
00018 {\cf20 // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL}\par
00019 {\cf20 // THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER}\par
00020 {\cf20 // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING}\par
00021 {\cf20 // FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS}\par
00022 {\cf20 // IN THE SOFTWARE.}\par
00023 {\cf20 //*****************************************************************************}\par
00024 \par
00025 {\cf20 //*****************************************************************************}\par
00026 {\cf20 // File: circular_queue.h}\par
00027 {\cf20 //}\par
00028 {\cf20 // This file contains the implementation of the CircularQueue class.}\par
00029 {\cf20 // Implementation is based on templates, so the class can be used with any type.}\par
00030 {\cf20 // CircularQueue is a queue implementation that uses an array as a base}\par
00031 {\cf20 // structure. It doesn't allocate memory on the heap, but it has a fixed}\par
00032 {\cf20 // capacity.}\par
00033 {\cf20 //*****************************************************************************}\par
00034 \par
00035 {\cf21 #ifndef ALGLIB_INCLUDE_CIRCULARQUEUE_H_}\par
00036 {\cf21 #define ALGLIB_INCLUDE_CIRCULARQUEUE_H_}\par
00037 \par
00038 {\cf21 #include <array>}\par
00039 {\cf21 #include <stdexcept>}\par
00040 \par
00041 {\cf21 #include "constants.h"}\par
00042 \par
00046 {\cf17 namespace }alglib \{\par
00047 \par
00055 {\cf17 template} <{\cf17 typename} T, {\cf18 size_t} capacity>\par
00056 {\cf17 class }CircularQueue \{\par
00057  {\cf17 public}:\par
00058   {\cf20 // Constructor for the CircularQueue.}\par
00059   CircularQueue();\par
00060 \par
00061   {\cf20 // Manipulation methods for the queue.}\par
00062   {\cf18 bool} IsEmpty() {\cf17 const} {\cf17 noexcept};\par
00063   {\cf18 bool} IsFull() {\cf17 const} {\cf17 noexcept};\par
00064   T Dequeue();\par
00065   {\cf18 void} Enqueue(T value);\par
00066 \par
00067   {\cf20 // Methods for peeking at values in the queue.}\par
00068   T PeekFront() {\cf17 const};\par
00069   T PeekRear() {\cf17 const};\par
00070 \par
00071  {\cf17 private}:\par
00075   std::array<T, capacity> queue;\par
00079   {\cf18 size_t} front;\par
00083   {\cf18 size_t} size;\par
00084 \};\par
00085 \par
00090 {\cf17 template} <{\cf17 typename} T, {\cf18 size_t} capacity>\par
00091 CircularQueue<T, capacity>::CircularQueue() : front(0), size(0), queue() \{\}\par
00092 \par
00098 {\cf17 template} <{\cf17 typename} T, {\cf18 size_t} capacity>\par
00099 {\cf18 bool} CircularQueue<T, capacity>::IsEmpty() const noexcept \{\par
00100   {\cf19 return} size == 0;\par
00101 \}\par
00102 \par
00107 {\cf17 template} <{\cf17 typename} T, {\cf18 size_t} capacity>\par
00108 {\cf18 bool} CircularQueue<T, capacity>::IsFull() const noexcept \{\par
00109   {\cf19 return} size == capacity;\par
00110 \}\par
00111 \par
00117 {\cf17 template} <{\cf17 typename} T, {\cf18 size_t} capacity>\par
00118 T CircularQueue<T, capacity>::Dequeue() \{\par
00119   {\cf19 if} (IsEmpty()) \{\par
00120     {\cf19 throw} std::runtime_error(errors::kEmptyDeletion);\par
00121   \}\par
00122   T result\{queue.at(front)\};\par
00123   front = (front + 1) % capacity;\par
00124   --size;\par
00125   {\cf19 return} result;\par
00126 \}\par
00127 \par
00133 {\cf17 template} <{\cf17 typename} T, {\cf18 size_t} capacity>\par
00134 {\cf18 void} CircularQueue<T, capacity>::Enqueue(T value) \{\par
00135   {\cf19 if} (IsFull()) \{\par
00136     {\cf19 throw} std::runtime_error(errors::kObjectFull);\par
00137   \}\par
00138   {\cf18 size_t} rear\{(front + size) % capacity\};\par
00139   queue.at(rear) = value;\par
00140   ++size;\par
00141 \}\par
00142 \par
00147 {\cf17 template} <{\cf17 typename} T, {\cf18 size_t} capacity>\par
00148 T CircularQueue<T, capacity>::PeekFront(){\cf17  const }\{\par
00149   {\cf19 if} (IsEmpty()) \{\par
00150     {\cf19 throw} std::runtime_error(errors::kPeekAtEmpty);\par
00151   \}\par
00152   {\cf19 return} queue.at(front);\par
00153 \}\par
00154 \par
00160 {\cf17 template} <{\cf17 typename} T, {\cf18 size_t} capacity>\par
00161 T CircularQueue<T, capacity>::PeekRear(){\cf17  const }\{\par
00162   {\cf19 if} (IsEmpty()) \{\par
00163     {\cf19 throw} std::runtime_error(errors::kPeekAtEmpty);\par
00164   \}\par
00165   {\cf18 size_t} rear\{(front + size - 1) % capacity\};\par
00166   {\cf19 return} queue.at(rear);\par
00167 \}\par
00168 \par
00169 \}  {\cf20 // namespace alglib}\par
00170 \par
00171 {\cf21 #endif  }{\cf20 // ALGLIB_INCLUDE_CIRCULARQUEUE_H_}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Include/constants.h File Reference\par \pard\plain 
{\tc\tcl2 \v Include/constants.h}
{\xe \v Include/constants.h}
{\bkmkstart AAAAAAAAAM}
{\bkmkend AAAAAAAAAM}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <string>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b alglib}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default namespace for the AlgLib library. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b alglib::errors}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Namespace for errors in the AlgLib library. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr const char * {\b alglib::errors::kItemNotFound} \{"Item not found."\}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr const char * {\b alglib::errors::kIndexOutOfRange} \{"Index out of range."\}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr const char * {\b alglib::errors::kEmptyDeletion} \{"Cannot delete from empty object."\}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr const char * {\b alglib::errors::kObjectFull} \{"Object full."\}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr const char * {\b alglib::errors::kObjectEmpty} \{"Object empty."\}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr const char * {\b alglib::errors::kPeekAtEmpty} \{"Cannot peek at empty objects."\}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
constants.h\par \pard\plain 
{\tc\tcl2 \v Include/constants.h}
{\xe \v Include/constants.h}
{\bkmkstart AAAAAAAAAD}
{\bkmkend AAAAAAAAAD}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //*****************************************************************************}\par
00002 {\cf20 // The MIT License (MIT)}\par
00003 {\cf20 //}\par
00004 {\cf20 // Copyright \'A9 2024 Piotr Walczak}\par
00005 {\cf20 //}\par
00006 {\cf20 // Permission is hereby granted, free of charge, to any person obtaining a copy}\par
00007 {\cf20 // of this software and associated documentation files (the \'93Software\'94), to}\par
00008 {\cf20 // deal in the Software without restriction, including without limitation the}\par
00009 {\cf20 // rights to use, copy, modify, merge, publish, distribute, sublicense, and/or}\par
00010 {\cf20 // sell copies of the Software, and to permit persons to whom the Software is}\par
00011 {\cf20 // furnished to do so, subject to the following conditions:}\par
00012 {\cf20 //}\par
00013 {\cf20 // The above copyright notice and this permission notice shall be included in}\par
00014 {\cf20 // all copies or substantial portions of the Software.}\par
00015 {\cf20 //}\par
00016 {\cf20 // THE SOFTWARE IS PROVIDED \'93AS IS\'94, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR}\par
00017 {\cf20 // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,}\par
00018 {\cf20 // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL}\par
00019 {\cf20 // THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER}\par
00020 {\cf20 // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING}\par
00021 {\cf20 // FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS}\par
00022 {\cf20 // IN THE SOFTWARE.}\par
00023 {\cf20 //*****************************************************************************}\par
00024 \par
00025 {\cf20 //*****************************************************************************}\par
00026 {\cf20 // File: array_stack.h}\par
00027 {\cf20 //}\par
00028 {\cf20 // This file contains constant values that are used in the library.}\par
00029 {\cf20 //*****************************************************************************}\par
00030 \par
00031 {\cf21 #ifndef ALGLIB_INCLUDE_CONSTANTS_H_}\par
00032 {\cf21 #define ALGLIB_INCLUDE_CONSTANTS_H_}\par
00033 \par
00034 {\cf21 #include <string>}\par
00035 \par
00039 {\cf17 namespace }alglib \{\par
00040 \par
00044 {\cf17 namespace }errors \{\par
00045 \par
00046 {\cf20 // Error messages.}\par
00047 {\cf17 inline} {\cf17 constexpr} {\cf17 const} {\cf18 char}* kItemNotFound\{{\cf22 "Item not found."}\};\par
00048 {\cf17 inline} {\cf17 constexpr} {\cf17 const} {\cf18 char}* kIndexOutOfRange\{{\cf22 "Index out of range."}\};\par
00049 {\cf17 inline} {\cf17 constexpr} {\cf17 const} {\cf18 char}* kEmptyDeletion\{{\cf22 "Cannot delete from empty object."}\};\par
00050 {\cf17 inline} {\cf17 constexpr} {\cf17 const} {\cf18 char}* kObjectFull\{{\cf22 "Object full."}\};\par
00051 {\cf17 inline} {\cf17 constexpr} {\cf17 const} {\cf18 char}* kObjectEmpty\{{\cf22 "Object empty."}\};\par
00052 {\cf17 inline} {\cf17 constexpr} {\cf17 const} {\cf18 char}* kPeekAtEmpty\{{\cf22 "Cannot peek at empty objects."}\};\par
00053 \par
00054 \}  {\cf20 // namespace errors}\par
00055 \par
00056 \}  {\cf20 // namespace alglib}\par
00057 \par
00058 {\cf21 #endif  }{\cf20 // ALGLIB_INCLUDE_CONSTANTS_H_}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Include/doubly_linked_list.h File Reference\par \pard\plain 
{\tc\tcl2 \v Include/doubly_linked_list.h}
{\xe \v Include/doubly_linked_list.h}
{\bkmkstart AAAAAAAAAN}
{\bkmkend AAAAAAAAAN}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <cstdlib>}\par
{\f2 #include <functional>}\par
{\f2 #include "constants.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b alglib::DoublyLinkedList< T >}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Template based doubly linked list implementation. All nodes are dynamically allocated. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b alglib}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default namespace for the AlgLib library. }}\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
doubly_linked_list.h\par \pard\plain 
{\tc\tcl2 \v Include/doubly_linked_list.h}
{\xe \v Include/doubly_linked_list.h}
{\bkmkstart AAAAAAAAAE}
{\bkmkend AAAAAAAAAE}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //*****************************************************************************}\par
00002 {\cf20 // The MIT License (MIT)}\par
00003 {\cf20 //}\par
00004 {\cf20 // Copyright \'A9 2024 Piotr Walczak}\par
00005 {\cf20 //}\par
00006 {\cf20 // Permission is hereby granted, free of charge, to any person obtaining a copy}\par
00007 {\cf20 // of this software and associated documentation files (the \'93Software\'94), to}\par
00008 {\cf20 // deal in the Software without restriction, including without limitation the}\par
00009 {\cf20 // rights to use, copy, modify, merge, publish, distribute, sublicense, and/or}\par
00010 {\cf20 // sell copies of the Software, and to permit persons to whom the Software is}\par
00011 {\cf20 // furnished to do so, subject to the following conditions:}\par
00012 {\cf20 //}\par
00013 {\cf20 // The above copyright notice and this permission notice shall be included in}\par
00014 {\cf20 // all copies or substantial portions of the Software.}\par
00015 {\cf20 //}\par
00016 {\cf20 // THE SOFTWARE IS PROVIDED \'93AS IS\'94, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR}\par
00017 {\cf20 // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,}\par
00018 {\cf20 // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL}\par
00019 {\cf20 // THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER}\par
00020 {\cf20 // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING}\par
00021 {\cf20 // FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS}\par
00022 {\cf20 // IN THE SOFTWARE.}\par
00023 {\cf20 //*****************************************************************************}\par
00024 \par
00025 {\cf20 //*****************************************************************************}\par
00026 {\cf20 // File: doubly_linked_list.h}\par
00027 {\cf20 //}\par
00028 {\cf20 // This file contains the implementation of a Doubly Linked List.}\par
00029 {\cf20 // The Doubly Linked List is a data structure that consists of a sequence of}\par
00030 {\cf20 // elements, each containing a link to its previous element and a link to its}\par
00031 {\cf20 // next element. The Doubly Linked List allows for efficient insertion and}\par
00032 {\cf20 // deletion of elements at the beginning, end, and at any position in the list.}\par
00033 {\cf20 // The Doubly Linked List also allows for efficient traversal of the list and}\par
00034 {\cf20 // searching for elements in the list.}\par
00035 {\cf20 //*****************************************************************************}\par
00036 \par
00037 {\cf21 #ifndef ALGLIB_INCLUDE_DOUBLYLINKEDLIST_H_}\par
00038 {\cf21 #define ALGLIB_INCLUDE_DOUBLYLINKEDLIST_H_}\par
00039 \par
00040 {\cf21 #include <cstdlib>}\par
00041 {\cf21 #include <functional>}\par
00042 \par
00043 {\cf21 #include "constants.h"}\par
00044 \par
00048 {\cf17 namespace }alglib \{\par
00049 \par
00054 {\cf17 template} <{\cf17 typename} T>\par
00055 {\cf17 class }DoublyLinkedList \{\par
00056  {\cf17 public}:\par
00057   {\cf20 // Constructor for the doubly linked list.}\par
00058   DoublyLinkedList();\par
00059 \par
00060   {\cf20 // Methods for exploring the doubly linked list.}\par
00061   {\cf18 void} Traverse({\cf17 const} std::function<{\cf18 void}(T)> &visit_callback) {\cf17 noexcept};\par
00062   {\cf18 size_t} Size() {\cf17 const} {\cf17 noexcept};\par
00063   {\cf18 size_t} Find({\cf17 const} T value) {\cf17 const};\par
00064 \par
00065   {\cf20 // Method for converting the doubly linked list to a vector.}\par
00066   std::vector<T> GetAsVector() {\cf17 const} {\cf17 noexcept};\par
00067 \par
00068   {\cf20 // Methods for inserting elements into the doubly linked list.}\par
00069   {\cf18 void} InsertAtBeginning({\cf17 const} T data) {\cf17 noexcept};\par
00070   {\cf18 void} InsertAtEnd({\cf17 const} T data) {\cf17 noexcept};\par
00071   {\cf18 void} InsertAtPosition({\cf17 const} uint32_t pos, {\cf17 const} T data);\par
00072 \par
00073   {\cf20 // Methods for deleting elements from the doubly linked list.}\par
00074   {\cf18 void} DeleteAtBeginning();\par
00075   {\cf18 void} DeleteAtEnd();\par
00076   {\cf18 void} DeleteAtPosition(uint32_t pos);\par
00077 \par
00078   {\cf20 // Method for checking if the doubly linked list is empty.}\par
00079   {\cf18 bool} IsEmpty() {\cf17 const} {\cf17 noexcept};\par
00080 \par
00081   {\cf20 // Destructor for the doubly linked list.}\par
00082   ~DoublyLinkedList();\par
00083 \par
00084  {\cf17 private}:\par
00090   {\cf17 struct }Node \{\par
00091     Node(T data);\par
00092     ~Node() = {\cf19 default};\par
00093     Node *next;\par
00094     Node *previous;\par
00095     T data;\par
00096   \};\par
00097 \par
00098   {\cf20 // Head and tail pointers for the doubly linked list.}\par
00099   Node *head_;\par
00100   Node *tail_;\par
00101 \};\par
00102 \par
00108 {\cf17 template} <{\cf17 typename} T>\par
00109 DoublyLinkedList<T>::Node::Node({\cf17 const} T data)\par
00110     : next(nullptr), previous(nullptr), data(data) \{\}\par
00111 \par
00116 {\cf17 template} <{\cf17 typename} T>\par
00117 DoublyLinkedList<T>::DoublyLinkedList() : head_(nullptr), tail_(nullptr) \{\}\par
00118 \par
00123 {\cf17 template} <{\cf17 typename} T>\par
00124 {\cf18 void} DoublyLinkedList<T>::Traverse(\par
00125     {\cf17 const} std::function<{\cf18 void}(T)> &visit_callback) {\cf17 noexcept} \{\par
00126   Node *tmp\{head_\};\par
00127   {\cf19 while} (tmp) \{\par
00128     visit_callback(tmp->data);\par
00129     tmp = tmp->next;\par
00130   \}\par
00131 \}\par
00132 \par
00139 {\cf17 template} <{\cf17 typename} T>\par
00140 {\cf18 size_t} DoublyLinkedList<T>::Size() const noexcept \{\par
00141   Node *tmp\{head_\};\par
00142   {\cf18 size_t} count\{\};\par
00143   {\cf19 while} (tmp) \{\par
00144     ++count;\par
00145     tmp = tmp->next;\par
00146   \}\par
00147   {\cf19 return} count;\par
00148 \}\par
00149 \par
00156 {\cf17 template} <{\cf17 typename} T>\par
00157 {\cf18 size_t} DoublyLinkedList<T>::Find({\cf17 const} T value){\cf17  const }\{\par
00158   Node *tmp\{head_\};\par
00159   {\cf18 size_t} count\{\};\par
00160   {\cf19 while} (tmp && tmp->data != value) \{\par
00161     ++count;\par
00162     tmp = tmp->next;\par
00163   \}\par
00164   {\cf19 if} (tmp == {\cf17 nullptr}) \{\par
00165     {\cf19 throw} std::runtime_error(errors::kItemNotFound);\par
00166   \} {\cf19 else} \{\par
00167     {\cf19 return} count;\par
00168   \}\par
00169 \}\par
00170 \par
00180 {\cf17 template} <{\cf17 typename} T>\par
00181 std::vector<T> DoublyLinkedList<T>::GetAsVector() const noexcept \{\par
00182   std::vector<T> vec\{\};\par
00183   vec.reserve(Size());\par
00184   Node *tmp\{head_\};\par
00185   {\cf19 while} (tmp) \{\par
00186     vec.emplace_back(tmp->data);\par
00187     tmp = tmp->next;\par
00188   \}\par
00189   {\cf19 return} vec;\par
00190 \}\par
00191 \par
00199 {\cf17 template} <{\cf17 typename} T>\par
00200 {\cf18 void} DoublyLinkedList<T>::InsertAtBeginning({\cf17 const} T data) {\cf17 noexcept} \{\par
00201   Node *new_node\{{\cf17 new} Node(data)\};\par
00202   {\cf19 if} (IsEmpty()) \{\par
00203     head_ = new_node;\par
00204     tail_ = new_node;\par
00205   \} {\cf19 else} \{\par
00206     new_node->next = head_;\par
00207     head_->previous = new_node;\par
00208     head_ = new_node;\par
00209   \}\par
00210 \}\par
00211 \par
00219 {\cf17 template} <{\cf17 typename} T>\par
00220 {\cf18 void} DoublyLinkedList<T>::InsertAtEnd({\cf17 const} T data) {\cf17 noexcept} \{\par
00221   Node *new_node\{{\cf17 new} Node(data)\};\par
00222   {\cf19 if} (IsEmpty()) \{\par
00223     head_ = new_node;\par
00224     tail_ = new_node;\par
00225   \} {\cf19 else} \{\par
00226     tail_->next = new_node;\par
00227     new_node->previous = tail_;\par
00228     tail_ = new_node;\par
00229   \}\par
00230 \}\par
00231 \par
00240 {\cf17 template} <{\cf17 typename} T>\par
00241 {\cf18 void} DoublyLinkedList<T>::InsertAtPosition({\cf17 const} uint32_t pos, {\cf17 const} T data) \{\par
00242   {\cf17 const} {\cf18 size_t} current_size\{Size()\};\par
00243   {\cf19 if} (pos > current_size) \{\par
00244     {\cf19 throw} std::runtime_error(errors::kIndexOutOfRange);\par
00245   \}\par
00246   {\cf19 if} (pos == 0) \{\par
00247     InsertAtBeginning(data);\par
00248     {\cf19 return};\par
00249   \}\par
00250   {\cf19 if} (pos == current_size) \{\par
00251     InsertAtEnd(data);\par
00252     {\cf19 return};\par
00253   \}\par
00254   Node *new_node = {\cf17 new} Node(data);\par
00255   Node *prev_node = head_;\par
00256   {\cf19 for} (uint32_t i\{\}; i < pos - 1; ++i) \{\par
00257     prev_node = prev_node->next;\par
00258   \}\par
00259   Node *next_node\{prev_node->next\};\par
00260   new_node->next = next_node;\par
00261   new_node->previous = prev_node;\par
00262   prev_node->next = new_node;\par
00263   {\cf19 if} (next_node) \{\par
00264     next_node->previous = new_node;\par
00265   \}\par
00266 \}\par
00267 \par
00273 {\cf17 template} <{\cf17 typename} T>\par
00274 {\cf18 void} DoublyLinkedList<T>::DeleteAtBeginning() \{\par
00275   {\cf19 if} (IsEmpty()) \{\par
00276     {\cf19 throw} std::runtime_error(errors::kEmptyDeletion);\par
00277   \}\par
00278   {\cf19 if} (head_ == tail_) \{\par
00279     {\cf17 delete} head_;\par
00280     head_ = {\cf17 nullptr};\par
00281     tail_ = {\cf17 nullptr};\par
00282   \} {\cf19 else} \{\par
00283     Node *tmp\{head_\};\par
00284     head_ = head_->next;\par
00285     head_->previous = {\cf17 nullptr};\par
00286     {\cf17 delete} tmp;\par
00287   \}\par
00288 \}\par
00289 \par
00295 {\cf17 template} <{\cf17 typename} T>\par
00296 {\cf18 void} DoublyLinkedList<T>::DeleteAtEnd() \{\par
00297   {\cf19 if} (IsEmpty()) \{\par
00298     {\cf19 throw} std::runtime_error(errors::kEmptyDeletion);\par
00299   \}\par
00300   {\cf19 if} (head_ == tail_) \{\par
00301     {\cf17 delete} head_;\par
00302     head_ = {\cf17 nullptr};\par
00303     tail_ = {\cf17 nullptr};\par
00304   \} {\cf19 else} \{\par
00305     Node *tmp\{tail_\};\par
00306     tail_ = tail_->previous;\par
00307     tail_->next = {\cf17 nullptr};\par
00308     {\cf17 delete} tmp;\par
00309   \}\par
00310 \}\par
00311 \par
00318 {\cf17 template} <{\cf17 typename} T>\par
00319 {\cf18 void} DoublyLinkedList<T>::DeleteAtPosition(uint32_t pos) \{\par
00320   {\cf19 if} (IsEmpty()) \{\par
00321     {\cf19 throw} std::runtime_error(errors::kEmptyDeletion);\par
00322   \}\par
00323   {\cf17 const} {\cf18 size_t} current_size\{Size()\};\par
00324   {\cf19 if} (pos >= current_size) \{\par
00325     {\cf19 throw} std::runtime_error(errors::kIndexOutOfRange);\par
00326   \}\par
00327   {\cf19 if} (pos == 0) \{\par
00328     DeleteAtBeginning();\par
00329     {\cf19 return};\par
00330   \}\par
00331   {\cf19 if} (pos == current_size - 1) \{\par
00332     DeleteAtEnd();\par
00333     {\cf19 return};\par
00334   \}\par
00335   Node *curr\{head_\};\par
00336   {\cf19 for} (uint32_t i\{\}; i < pos; ++i) \{\par
00337     curr = curr->next;\par
00338   \}\par
00339   Node *prev_node\{curr->previous\};\par
00340   Node *next_node\{curr->next\};\par
00341   {\cf19 if} (prev_node) \{\par
00342     prev_node->next = next_node;\par
00343   \}\par
00344   {\cf19 if} (next_node) \{\par
00345     next_node->previous = next_node;\par
00346   \}\par
00347   {\cf17 delete} curr;\par
00348 \}\par
00349 \par
00354 {\cf17 template} <{\cf17 typename} T>\par
00355 DoublyLinkedList<T>::~DoublyLinkedList() \{\par
00356   Node *tmp\{head_\};\par
00357   {\cf19 while} (tmp) \{\par
00358     Node *next\{tmp->next\};\par
00359     {\cf17 delete} tmp;\par
00360     tmp = next;\par
00361   \}\par
00362   head_ = {\cf17 nullptr};\par
00363   tail_ = {\cf17 nullptr};\par
00364 \}\par
00365 \par
00370 {\cf17 template} <{\cf17 typename} T>\par
00371 {\cf18 bool} DoublyLinkedList<T>::IsEmpty() const noexcept \{\par
00372   {\cf19 return} (head_ == {\cf17 nullptr});\par
00373 \}\par
00374 \par
00375 \}  {\cf20 // namespace alglib}\par
00376 \par
00377 {\cf21 #endif  }{\cf20 // ALGLIB_INCLUDE_DOUBLYLINKEDLIST_H_}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Include/singly_linked_list.h File Reference\par \pard\plain 
{\tc\tcl2 \v Include/singly_linked_list.h}
{\xe \v Include/singly_linked_list.h}
{\bkmkstart AAAAAAAAAO}
{\bkmkend AAAAAAAAAO}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <cstdlib>}\par
{\f2 #include <functional>}\par
{\f2 #include <vector>}\par
{\f2 #include "constants.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b alglib::SinglyLinkedList< T >}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Template based singly linked list implementation. All nodes are dynamically allocated. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b alglib}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default namespace for the AlgLib library. }}\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
singly_linked_list.h\par \pard\plain 
{\tc\tcl2 \v Include/singly_linked_list.h}
{\xe \v Include/singly_linked_list.h}
{\bkmkstart AAAAAAAAAF}
{\bkmkend AAAAAAAAAF}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //*****************************************************************************}\par
00002 {\cf20 // The MIT License (MIT)}\par
00003 {\cf20 //}\par
00004 {\cf20 // Copyright \'A9 2024 Piotr Walczak}\par
00005 {\cf20 //}\par
00006 {\cf20 // Permission is hereby granted, free of charge, to any person obtaining a copy}\par
00007 {\cf20 // of this software and associated documentation files (the \'93Software\'94), to}\par
00008 {\cf20 // deal in the Software without restriction, including without limitation the}\par
00009 {\cf20 // rights to use, copy, modify, merge, publish, distribute, sublicense, and/or}\par
00010 {\cf20 // sell copies of the Software, and to permit persons to whom the Software is}\par
00011 {\cf20 // furnished to do so, subject to the following conditions:}\par
00012 {\cf20 //}\par
00013 {\cf20 // The above copyright notice and this permission notice shall be included in}\par
00014 {\cf20 // all copies or substantial portions of the Software.}\par
00015 {\cf20 //}\par
00016 {\cf20 // THE SOFTWARE IS PROVIDED \'93AS IS\'94, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR}\par
00017 {\cf20 // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,}\par
00018 {\cf20 // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL}\par
00019 {\cf20 // THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER}\par
00020 {\cf20 // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING}\par
00021 {\cf20 // FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS}\par
00022 {\cf20 // IN THE SOFTWARE.}\par
00023 {\cf20 //*****************************************************************************}\par
00024 \par
00025 {\cf20 //*****************************************************************************}\par
00026 {\cf20 // File: singly_linked_list.h}\par
00027 {\cf20 //}\par
00028 {\cf20 // This file contains the implementation of the SinglyLinkedList class.}\par
00029 {\cf20 // Implementation is based on templates, so the class can be used with any}\par
00030 {\cf20 // type. SinglyLinkedList contains methods for inserting, deleting, and}\par
00031 {\cf20 // searching for elements. It has its own node structure that contains the}\par
00032 {\cf20 // data and a pointer to the next node. The class is implemented in the}\par
00033 {\cf20 // alglib namespace.}\par
00034 {\cf20 //*****************************************************************************}\par
00035 \par
00036 {\cf21 #ifndef ALGLIB_INCLUDE_SINGLYLINKEDLIST_H_}\par
00037 {\cf21 #define ALGLIB_INCLUDE_SINGLYLINKEDLIST_H_}\par
00038 \par
00039 {\cf21 #include <cstdlib>}\par
00040 {\cf21 #include <functional>}\par
00041 {\cf21 #include <vector>}\par
00042 \par
00043 {\cf21 #include "constants.h"}\par
00044 \par
00048 {\cf17 namespace }alglib \{\par
00049 \par
00054 {\cf17 template} <{\cf17 typename} T>\par
00055 {\cf17 class }SinglyLinkedList \{\par
00056  {\cf17 public}:\par
00057   {\cf20 // Constructor for the singly linked list.}\par
00058   SinglyLinkedList();\par
00059 \par
00060   {\cf20 // Methods for exploring the singly linked list.}\par
00061   {\cf18 void} Traverse({\cf17 const} std::function<{\cf18 void}(T)> &visit_callback) {\cf17 noexcept};\par
00062   {\cf18 size_t} Size() {\cf17 const} {\cf17 noexcept};\par
00063   {\cf18 size_t} Find(T value) {\cf17 const};\par
00064 \par
00065   {\cf20 // Method for converting the singly linked list to a vector.}\par
00066   std::vector<T> GetAsVector() {\cf17 const} {\cf17 noexcept};\par
00067 \par
00068   {\cf20 // Insertion methods}\par
00069   {\cf18 void} InsertAtBeginning(T value) {\cf17 noexcept};\par
00070   {\cf18 void} InsertAtEnd(T value) {\cf17 noexcept};\par
00071   {\cf18 void} InsertAtPosition(uint32_t pos, T value);\par
00072 \par
00073   {\cf20 // Deletion methods}\par
00074   {\cf18 void} DeleteAtBeggining();\par
00075   {\cf18 void} DeleteAtEnd();\par
00076   {\cf18 void} DeleteAtPosition(uint32_t pos);\par
00077 \par
00078   {\cf20 // Destructor for the singly linked list.}\par
00079   ~SinglyLinkedList();\par
00080 \par
00081  {\cf17 private}:\par
00086   {\cf17 struct }Node \{\par
00087     {\cf20 // Constructor for the Node structure.}\par
00088     Node(T data);\par
00089     {\cf20 // Destructor for the Node structure.}\par
00090     ~Node() = {\cf19 default};\par
00091 \par
00095     Node *next;\par
00099     T data;\par
00100   \};\par
00101 \par
00105   Node *head_;\par
00106 \};\par
00107 \par
00114 {\cf17 template} <{\cf17 typename} T>\par
00115 SinglyLinkedList<T>::Node::Node(T data) : next(nullptr), data(data) \{\}\par
00116 \par
00121 {\cf17 template} <{\cf17 typename} T>\par
00122 SinglyLinkedList<T>::SinglyLinkedList() : head_(nullptr) \{\}\par
00123 \par
00130 {\cf17 template} <{\cf17 typename} T>\par
00131 {\cf18 void} SinglyLinkedList<T>::Traverse(\par
00132     {\cf17 const} std::function<{\cf18 void}(T)> &visit_callback) {\cf17 noexcept} \{\par
00133   Node *tmp\{head_\};\par
00134   {\cf19 while} (tmp) \{\par
00135     visit_callback(tmp->data);\par
00136     tmp = tmp->next;\par
00137   \}\par
00138 \}\par
00139 \par
00145 {\cf17 template} <{\cf17 typename} T>\par
00146 {\cf18 size_t} SinglyLinkedList<T>::Size() const noexcept \{\par
00147   Node *tmp\{head_\};\par
00148   {\cf18 size_t} count\{\};\par
00149   {\cf19 while} (tmp) \{\par
00150     ++count;\par
00151     tmp = tmp->next;\par
00152   \}\par
00153   {\cf19 return} count;\par
00154 \}\par
00155 \par
00161 {\cf17 template} <{\cf17 typename} T>\par
00162 {\cf18 size_t} SinglyLinkedList<T>::Find(T value){\cf17  const }\{\par
00163   Node *tmp\{head_\};\par
00164 \par
00165   {\cf18 size_t} count\{\};\par
00166   {\cf19 while} (tmp && tmp->data != value) \{\par
00167     ++count;\par
00168     tmp = tmp->next;\par
00169   \}\par
00170 \par
00171   {\cf19 if} (tmp == {\cf17 nullptr}) \{\par
00172     {\cf19 throw} std::runtime_error(errors::kItemNotFound);\par
00173   \} {\cf19 else} \{\par
00174     {\cf19 return} count;\par
00175   \}\par
00176 \}\par
00177 \par
00185 {\cf17 template} <{\cf17 typename} T>\par
00186 std::vector<T> SinglyLinkedList<T>::GetAsVector() const noexcept \{\par
00187   std::vector<T> vec\{\};\par
00188   vec.reserve(Size());\par
00189   Node *tmp\{head_\};\par
00190   {\cf19 while} (tmp) \{\par
00191     vec.emplace_back(tmp->data);\par
00192     tmp = tmp->next;\par
00193   \}\par
00194   {\cf19 return} vec;\par
00195 \}\par
00196 \par
00202 {\cf17 template} <{\cf17 typename} T>\par
00203 {\cf18 void} SinglyLinkedList<T>::InsertAtBeginning(T value) {\cf17 noexcept} \{\par
00204   Node *new_node\{{\cf17 new} Node(value)\};\par
00205   new_node->next = head_;\par
00206   head_ = new_node;\par
00207 \}\par
00208 \par
00214 {\cf17 template} <{\cf17 typename} T>\par
00215 {\cf18 void} SinglyLinkedList<T>::InsertAtEnd(T value) {\cf17 noexcept} \{\par
00216   Node *new_node\{{\cf17 new} Node(value)\};\par
00217 \par
00218   {\cf19 if} (head_ == {\cf17 nullptr}) \{\par
00219     head_ = new_node;\par
00220     {\cf19 return};\par
00221   \}\par
00222 \par
00223   Node *tmp\{head_\};\par
00224   {\cf19 while} (tmp->next) \{\par
00225     tmp = tmp->next;\par
00226   \}\par
00227 \par
00228   tmp->next = new_node;\par
00229 \}\par
00230 \par
00238 {\cf17 template} <{\cf17 typename} T>\par
00239 {\cf18 void} SinglyLinkedList<T>::InsertAtPosition(uint32_t pos, T value) \{\par
00240   {\cf19 if} (pos < 0) \{\par
00241     {\cf19 throw} std::runtime_error(errors::kIndexOutOfRange);\par
00242   \} {\cf19 else} {\cf19 if} (pos == 0) \{\par
00243     Node *newNode\{{\cf17 new} Node(value)\};\par
00244     newNode->next = head_;\par
00245     head_ = newNode;\par
00246   \} {\cf19 else} \{\par
00247     Node *tmp\{head_\};\par
00248     uint32_t count\{\};\par
00249     {\cf19 while} (count < pos - 1 && tmp != {\cf17 nullptr}) \{\par
00250       tmp = tmp->next;\par
00251       ++count;\par
00252     \}\par
00253     {\cf19 if} (tmp == {\cf17 nullptr}) {\cf19 throw} std::runtime_error(errors::kIndexOutOfRange);\par
00254     Node *newNode\{{\cf17 new} Node(value)\};\par
00255     newNode->next = tmp->next;\par
00256     tmp->next = newNode;\par
00257   \}\par
00258 \}\par
00259 \par
00264 {\cf17 template} <{\cf17 typename} T>\par
00265 {\cf18 void} SinglyLinkedList<T>::DeleteAtBeggining() \{\par
00266   {\cf19 if} (head_ == {\cf17 nullptr}) \{\par
00267     {\cf19 throw} std::runtime_error(errors::kEmptyDeletion);\par
00268   \} {\cf19 else} {\cf19 if} (head_->next == {\cf17 nullptr}) \{\par
00269     {\cf17 delete} head_;\par
00270     head_ = {\cf17 nullptr};\par
00271   \} {\cf19 else} \{\par
00272     Node *tmp\{head_\};\par
00273     head_ = head_->next;\par
00274     {\cf17 delete} tmp;\par
00275   \}\par
00276 \}\par
00277 \par
00282 {\cf17 template} <{\cf17 typename} T>\par
00283 {\cf18 void} SinglyLinkedList<T>::DeleteAtEnd() \{\par
00284   {\cf19 if} (head_ == {\cf17 nullptr}) \{\par
00285     {\cf19 throw} std::runtime_error(errors::kEmptyDeletion);\par
00286   \} {\cf19 else} {\cf19 if} (head_->next == {\cf17 nullptr}) \{\par
00287     {\cf17 delete} head_;\par
00288     head_ = {\cf17 nullptr};\par
00289   \} {\cf19 else} \{\par
00290     Node *tmp\{head_\};\par
00291     {\cf19 while} (tmp->next->next != {\cf17 nullptr}) tmp = tmp->next;\par
00292     {\cf17 delete} tmp->next;\par
00293     tmp->next = {\cf17 nullptr};\par
00294   \}\par
00295 \}\par
00296 \par
00302 {\cf17 template} <{\cf17 typename} T>\par
00303 {\cf18 void} SinglyLinkedList<T>::DeleteAtPosition(uint32_t pos) \{\par
00304   {\cf19 if} (head_ == {\cf17 nullptr}) \{\par
00305     {\cf19 throw} std::runtime_error(errors::kEmptyDeletion);\par
00306   \} {\cf19 else} {\cf19 if} (pos == 0) \{\par
00307     Node *tmp\{head_\};\par
00308     head_ = head_->next;\par
00309     {\cf17 delete} tmp;\par
00310   \} {\cf19 else} \{\par
00311     Node *tmp\{head_\};\par
00312     uint32_t count\{\};\par
00313     {\cf19 while} (count < pos - 1 && tmp != {\cf17 nullptr}) \{\par
00314       tmp = tmp->next;\par
00315       ++count;\par
00316     \}\par
00317     {\cf19 if} (tmp == {\cf17 nullptr} || tmp->next == {\cf17 nullptr})\par
00318       {\cf19 throw} std::runtime_error(errors::kIndexOutOfRange);\par
00319     Node *toDelete\{tmp->next\};\par
00320     tmp->next = toDelete->next;\par
00321     {\cf17 delete} toDelete;\par
00322   \}\par
00323 \}\par
00324 \par
00330 {\cf17 template} <{\cf17 typename} T>\par
00331 SinglyLinkedList<T>::~SinglyLinkedList() \{\par
00332   Node *tmp\{head_\};\par
00333   {\cf19 while} (tmp) \{\par
00334     Node *next\{tmp->next\};\par
00335     {\cf17 delete} tmp;\par
00336     tmp = next;\par
00337   \}\par
00338 \}\par
00339 \par
00340 \}  {\cf20 // namespace alglib}\par
00341 \par
00342 {\cf21 #endif  }{\cf20 // ALGLIB_INCLUDE_SINGLYLINKEDLIST_H_}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Include/sll_queue.h File Reference\par \pard\plain 
{\tc\tcl2 \v Include/sll_queue.h}
{\xe \v Include/sll_queue.h}
{\bkmkstart AAAAAAAAAP}
{\bkmkend AAAAAAAAAP}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdexcept>}\par
{\f2 #include "constants.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b alglib::SLLQueue< T >}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b SLLQueue} class is a queue data structure implemented using singly linked list. It allocates nodes on the heap. Queue can grow dynamically. There is no limit to the amount of elements besides the memory available. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b alglib}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default namespace for the AlgLib library. }}\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
sll_queue.h\par \pard\plain 
{\tc\tcl2 \v Include/sll_queue.h}
{\xe \v Include/sll_queue.h}
{\bkmkstart AAAAAAAAAG}
{\bkmkend AAAAAAAAAG}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //*****************************************************************************}\par
00002 {\cf20 // The MIT License (MIT)}\par
00003 {\cf20 //}\par
00004 {\cf20 // Copyright \'A9 2024 Piotr Walczak}\par
00005 {\cf20 //}\par
00006 {\cf20 // Permission is hereby granted, free of charge, to any person obtaining a copy}\par
00007 {\cf20 // of this software and associated documentation files (the \'93Software\'94), to}\par
00008 {\cf20 // deal in the Software without restriction, including without limitation the}\par
00009 {\cf20 // rights to use, copy, modify, merge, publish, distribute, sublicense, and/or}\par
00010 {\cf20 // sell copies of the Software, and to permit persons to whom the Software is}\par
00011 {\cf20 // furnished to do so, subject to the following conditions:}\par
00012 {\cf20 //}\par
00013 {\cf20 // The above copyright notice and this permission notice shall be included in}\par
00014 {\cf20 // all copies or substantial portions of the Software.}\par
00015 {\cf20 //}\par
00016 {\cf20 // THE SOFTWARE IS PROVIDED \'93AS IS\'94, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR}\par
00017 {\cf20 // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,}\par
00018 {\cf20 // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL}\par
00019 {\cf20 // THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER}\par
00020 {\cf20 // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING}\par
00021 {\cf20 // FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS}\par
00022 {\cf20 // IN THE SOFTWARE.}\par
00023 {\cf20 //*****************************************************************************}\par
00024 \par
00025 {\cf20 //*****************************************************************************}\par
00026 {\cf20 // File: sll_queue.h}\par
00027 {\cf20 //}\par
00028 {\cf20 // This file contains implementation of SLLQueue class. It uses singly linked}\par
00029 {\cf20 // list as a base for queue data structure. All nodes are allocated on the}\par
00030 {\cf20 //*****************************************************************************}\par
00031 \par
00032 {\cf21 #ifndef ALGLIB_INCLUDE_SLLQUEUE_H_}\par
00033 {\cf21 #define ALGLIB_INCLUDE_SLLQUEUE_H_}\par
00034 \par
00035 {\cf21 #include <stdexcept>}\par
00036 \par
00037 {\cf21 #include "constants.h"}\par
00038 \par
00042 {\cf17 namespace }alglib \{\par
00043 \par
00050 {\cf17 template} <{\cf17 typename} T>\par
00051 {\cf17 class }SLLQueue \{\par
00052  {\cf17 public}:\par
00053   {\cf20 // Constructor for the SLLQueue.}\par
00054   SLLQueue();\par
00055 \par
00056   {\cf20 // Manipulation methods for the queue.}\par
00057   {\cf18 bool} IsEmpty() {\cf17 const} {\cf17 noexcept};\par
00058   T Dequeue();\par
00059   {\cf18 void} Enqueue(T value) {\cf17 noexcept};\par
00060 \par
00061   {\cf20 // Methods for peeking at the front and rear of the queue.}\par
00062   T PeekFront() {\cf17 const};\par
00063   T PeekRear() {\cf17 const};\par
00064 \par
00065   {\cf20 // Destructor for the SLLQueue.}\par
00066   ~SLLQueue();\par
00067 \par
00068  {\cf17 private}:\par
00073   {\cf17 struct }Node \{\par
00074     T val;\par
00075     Node *next;\par
00076     Node(T value);\par
00077   \};\par
00081   Node *front;\par
00085   Node *rear;\par
00086 \};\par
00087 \par
00093 {\cf17 template} <{\cf17 typename} T>\par
00094 SLLQueue<T>::Node::Node(T value) : val(value), next(nullptr) \{\}\par
00095 \par
00099 {\cf17 template} <{\cf17 typename} T>\par
00100 SLLQueue<T>::SLLQueue() : front(nullptr), rear(nullptr) \{\}\par
00101 \par
00106 {\cf17 template} <{\cf17 typename} T>\par
00107 {\cf18 bool} SLLQueue<T>::IsEmpty() const noexcept \{\par
00108   {\cf19 return} front == {\cf17 nullptr};\par
00109 \}\par
00110 \par
00119 {\cf17 template} <{\cf17 typename} T>\par
00120 T SLLQueue<T>::Dequeue() \{\par
00121   {\cf19 if} (IsEmpty()) \{\par
00122     {\cf19 throw} std::runtime_error(errors::kEmptyDeletion);\par
00123   \}\par
00124   T result\{front->val\};\par
00125   Node *tmp\{front\};\par
00126   front = front->next;\par
00127   {\cf19 if} (front == {\cf17 nullptr}) \{\par
00128     rear = {\cf17 nullptr};\par
00129   \}\par
00130   {\cf17 delete} tmp;\par
00131   {\cf19 return} result;\par
00132 \}\par
00133 \par
00140 {\cf17 template} <{\cf17 typename} T>\par
00141 {\cf18 void} SLLQueue<T>::Enqueue(T value) {\cf17 noexcept} \{\par
00142   Node *new_node\{{\cf17 new} Node(value)\};\par
00143   {\cf19 if} (IsEmpty()) \{\par
00144     front = rear = new_node;\par
00145   \}\par
00146   rear->next = new_node;\par
00147   rear = rear->next;\par
00148 \}\par
00149 \par
00156 {\cf17 template} <{\cf17 typename} T>\par
00157 T SLLQueue<T>::PeekFront(){\cf17  const }\{\par
00158   {\cf19 if} (IsEmpty()) \{\par
00159     {\cf19 throw} std::runtime_error(errors::kObjectEmpty);\par
00160   \}\par
00161   {\cf19 return} front->val;\par
00162 \}\par
00163 \par
00170 {\cf17 template} <{\cf17 typename} T>\par
00171 T SLLQueue<T>::PeekRear(){\cf17  const }\{\par
00172   {\cf19 if} (IsEmpty()) \{\par
00173     {\cf19 throw} std::runtime_error(errors::kObjectEmpty);\par
00174   \}\par
00175   {\cf19 return} rear->val;\par
00176 \}\par
00177 \par
00183 {\cf17 template} <{\cf17 typename} T>\par
00184 SLLQueue<T>::~SLLQueue() \{\par
00185   Node *tmp\{front\};\par
00186   {\cf19 while} (tmp != rear) \{\par
00187     Node *next\{tmp->next\};\par
00188     {\cf17 delete} tmp;\par
00189     tmp = next;\par
00190   \}\par
00191   {\cf17 delete} rear;\par
00192 \}\par
00193 \par
00194 \}  {\cf20 // namespace alglib}\par
00195 \par
00196 {\cf21 #endif  }{\cf20 // ALGLIB_INCLUDE_SLLQUEUE_H_}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Include/sll_stack.h File Reference\par \pard\plain 
{\tc\tcl2 \v Include/sll_stack.h}
{\xe \v Include/sll_stack.h}
{\bkmkstart AAAAAAAAAQ}
{\bkmkend AAAAAAAAAQ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdexcept>}\par
{\f2 #include "constants.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b alglib::SLLStack< T >}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b SLLStack} is a stack implementation that uses a singly linked list as a base structure. It allocates memory on the heap, so the stack can grow dynamically. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b alglib}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default namespace for the AlgLib library. }}\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
sll_stack.h\par \pard\plain 
{\tc\tcl2 \v Include/sll_stack.h}
{\xe \v Include/sll_stack.h}
{\bkmkstart AAAAAAAAAH}
{\bkmkend AAAAAAAAAH}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //*****************************************************************************}\par
00002 {\cf20 // The MIT License (MIT)}\par
00003 {\cf20 //}\par
00004 {\cf20 // Copyright \'A9 2024 Piotr Walczak}\par
00005 {\cf20 //}\par
00006 {\cf20 // Permission is hereby granted, free of charge, to any person obtaining a copy}\par
00007 {\cf20 // of this software and associated documentation files (the \'93Software\'94), to}\par
00008 {\cf20 // deal in the Software without restriction, including without limitation the}\par
00009 {\cf20 // rights to use, copy, modify, merge, publish, distribute, sublicense, and/or}\par
00010 {\cf20 // sell copies of the Software, and to permit persons to whom the Software is}\par
00011 {\cf20 // furnished to do so, subject to the following conditions:}\par
00012 {\cf20 //}\par
00013 {\cf20 // The above copyright notice and this permission notice shall be included in}\par
00014 {\cf20 // all copies or substantial portions of the Software.}\par
00015 {\cf20 //}\par
00016 {\cf20 // THE SOFTWARE IS PROVIDED \'93AS IS\'94, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR}\par
00017 {\cf20 // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,}\par
00018 {\cf20 // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL}\par
00019 {\cf20 // THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER}\par
00020 {\cf20 // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING}\par
00021 {\cf20 // FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS}\par
00022 {\cf20 // IN THE SOFTWARE.}\par
00023 {\cf20 //*****************************************************************************}\par
00024 \par
00025 {\cf20 //*****************************************************************************}\par
00026 {\cf20 // File: sll_stack.h}\par
00027 {\cf20 //}\par
00028 {\cf20 // This file contains the implementation of the ListStack class. Implementation}\par
00029 {\cf20 // is based on templates, so the class can be used with any type. ListStack}\par
00030 {\cf20 // is a stack implementation that uses a singly linked list as a base structure.}\par
00031 {\cf20 // It allocates memory on the heap, so the stack can grow dynamically. The class}\par
00032 {\cf20 // is implemented in the alglib namespace.}\par
00033 {\cf20 //*****************************************************************************}\par
00034 \par
00035 {\cf21 #ifndef ALGLIB_INCLUDE_LISTSTACK_H_}\par
00036 {\cf21 #define ALGLIB_INCLUDE_LISTSTACK_H_}\par
00037 \par
00038 {\cf21 #include <stdexcept>}\par
00039 \par
00040 {\cf21 #include "constants.h"}\par
00041 \par
00045 {\cf17 namespace }alglib \{\par
00046 \par
00053 {\cf17 template} <{\cf17 typename} T>\par
00054 {\cf17 class }SLLStack \{\par
00055  {\cf17 public}:\par
00056   {\cf20 // Constructor for the ArrayStack.}\par
00057   SLLStack();\par
00058 \par
00059   {\cf20 // Methods for manipulating the stack.}\par
00060   {\cf18 void} Push(T val) {\cf17 noexcept};\par
00061   T Pop();\par
00062   T Top() {\cf17 const};\par
00063   {\cf18 bool} IsEmpty() {\cf17 const} {\cf17 noexcept};\par
00064   {\cf18 size_t} Size() {\cf17 const} {\cf17 noexcept};\par
00065 \par
00066   {\cf20 // Destructor for the ArrayStack.}\par
00067   ~SLLStack();\par
00068 \par
00069  {\cf17 private}:\par
00074   {\cf17 struct }Node \{\par
00075     Node(T data);\par
00076     T data;\par
00077     Node *next;\par
00078   \};\par
00079 \par
00083   Node *top;\par
00084 \};\par
00085 \par
00090 {\cf17 template} <{\cf17 typename} T>\par
00091 SLLStack<T>::Node::Node(T data) : data(data), next(nullptr) \{\}\par
00092 \par
00096 {\cf17 template} <{\cf17 typename} T>\par
00097 SLLStack<T>::SLLStack() : top(nullptr) \{\}\par
00098 \par
00105 {\cf17 template} <{\cf17 typename} T>\par
00106 {\cf18 void} SLLStack<T>::Push(T val) {\cf17 noexcept} \{\par
00107   Node *new_node\{{\cf17 new} Node(val)\};\par
00108   new_node->next = top;\par
00109   top = new_node;\par
00110 \}\par
00111 \par
00117 {\cf17 template} <{\cf17 typename} T>\par
00118 T SLLStack<T>::Pop() \{\par
00119   {\cf19 if} (IsEmpty()) \{\par
00120     {\cf19 throw} std::runtime_error(errors::kEmptyDeletion);\par
00121   \}\par
00122   T val\{top->data\};\par
00123   Node *tmp\{top\};\par
00124   top = top->next;\par
00125   {\cf17 delete} tmp;\par
00126   {\cf19 return} val;\par
00127 \}\par
00128 \par
00133 {\cf17 template} <{\cf17 typename} T>\par
00134 T SLLStack<T>::Top(){\cf17  const }\{\par
00135   {\cf19 if} (IsEmpty()) \{\par
00136     {\cf19 throw} std::runtime_error(errors::kPeekAtEmpty);\par
00137   \}\par
00138   {\cf19 return} top->data;\par
00139 \}\par
00140 \par
00145 {\cf17 template} <{\cf17 typename} T>\par
00146 {\cf18 bool} SLLStack<T>::IsEmpty() const noexcept \{\par
00147   {\cf19 return} top == {\cf17 nullptr};\par
00148 \}\par
00149 \par
00154 {\cf17 template} <{\cf17 typename} T>\par
00155 {\cf18 size_t} SLLStack<T>::Size() const noexcept \{\par
00156   {\cf18 size_t} count\{\};\par
00157   Node *tmp\{top\};\par
00158   {\cf19 while} (tmp) \{\par
00159     ++count;\par
00160     tmp = tmp->next;\par
00161   \}\par
00162   {\cf19 return} count;\par
00163 \}\par
00164 \par
00168 {\cf17 template} <{\cf17 typename} T>\par
00169 SLLStack<T>::~SLLStack() \{\par
00170   Node *tmp\{top\};\par
00171   {\cf19 while} (tmp) \{\par
00172     Node *next\{tmp->next\};\par
00173     {\cf17 delete} tmp;\par
00174     tmp = next;\par
00175   \}\par
00176 \}\par
00177 \par
00178 \}  {\cf20 // namespace alglib}\par
00179 \par
00180 {\cf21 #endif  }{\cf20 // ALGLIB_INCLUDE_LISTSTACK_H_}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Include/vector.h File Reference\par \pard\plain 
{\tc\tcl2 \v Include/vector.h}
{\xe \v Include/vector.h}
{\bkmkstart AAAAAAAAAR}
{\bkmkend AAAAAAAAAR}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "constants.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b alglib::Vector< T >}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Template based vector implementation that uses an array as a base structure. It allocates memory on the heap, and it can grow dynamically. Capacity doubles every time the size exceeds current capacity. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b alglib}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default namespace for the AlgLib library. }}\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
vector.h\par \pard\plain 
{\tc\tcl2 \v Include/vector.h}
{\xe \v Include/vector.h}
{\bkmkstart AAAAAAAAAI}
{\bkmkend AAAAAAAAAI}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //*****************************************************************************}\par
00002 {\cf20 // The MIT License (MIT)}\par
00003 {\cf20 //}\par
00004 {\cf20 // Copyright \'A9 2024 Piotr Walczak}\par
00005 {\cf20 //}\par
00006 {\cf20 // Permission is hereby granted, free of charge, to any person obtaining a copy}\par
00007 {\cf20 // of this software and associated documentation files (the \'93Software\'94), to}\par
00008 {\cf20 // deal in the Software without restriction, including without limitation the}\par
00009 {\cf20 // rights to use, copy, modify, merge, publish, distribute, sublicense, and/or}\par
00010 {\cf20 // sell copies of the Software, and to permit persons to whom the Software is}\par
00011 {\cf20 // furnished to do so, subject to the following conditions:}\par
00012 {\cf20 //}\par
00013 {\cf20 // The above copyright notice and this permission notice shall be included in}\par
00014 {\cf20 // all copies or substantial portions of the Software.}\par
00015 {\cf20 //}\par
00016 {\cf20 // THE SOFTWARE IS PROVIDED \'93AS IS\'94, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR}\par
00017 {\cf20 // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,}\par
00018 {\cf20 // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL}\par
00019 {\cf20 // THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER}\par
00020 {\cf20 // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING}\par
00021 {\cf20 // FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS}\par
00022 {\cf20 // IN THE SOFTWARE.}\par
00023 {\cf20 //*****************************************************************************}\par
00024 \par
00025 {\cf20 //*****************************************************************************}\par
00026 {\cf20 // File: vector.h}\par
00027 {\cf20 //}\par
00028 {\cf20 // This file contains the implementation of the Vector class. Implementation}\par
00029 {\cf20 // is based on templates, so the class can be used with any type. Vector class}\par
00030 {\cf20 // implements an array that can be extended and shrinked. All elements are}\par
00031 {\cf20 // allocated on the heap. Capacity doubles every time the size exceeds current}\par
00032 {\cf20 // capacity.}\par
00033 {\cf20 //*****************************************************************************}\par
00034 \par
00035 {\cf21 #ifndef ALGLIB_INCLUDE_VECTOR_H_}\par
00036 {\cf21 #define ALGLIB_INCLUDE_VECTOR_H_}\par
00037 \par
00038 {\cf21 #include "constants.h"}\par
00039 \par
00043 {\cf17 namespace }alglib \{\par
00044 \par
00051 {\cf17 template} <{\cf17 typename} T>\par
00052 {\cf17 class }Vector \{\par
00053  {\cf17 public}:\par
00054   {\cf20 // Constructors for vector class;}\par
00055   Vector() {\cf17 noexcept};\par
00056   Vector({\cf18 size_t} elements) {\cf17 noexcept};\par
00057   Vector({\cf18 size_t} elements, {\cf17 const} T& value) {\cf17 noexcept};\par
00058 \par
00059   {\cf20 // Inserting and removing elements from the vector.}\par
00060   {\cf18 void} Push({\cf17 const} T& value) {\cf17 noexcept};\par
00061   {\cf18 void} Insert({\cf17 const} T& value, {\cf18 size_t} index);\par
00062   T& Pop();\par
00063 \par
00064   {\cf20 // Accessing elements in the vector.}\par
00065   T& At({\cf18 size_t} index);\par
00066   {\cf17 const} T& At({\cf18 size_t} index) {\cf17 const};\par
00067 \par
00068   {\cf20 // Getting size and capacity of the vector.}\par
00069   {\cf18 size_t} Size() {\cf17 const} {\cf17 noexcept};\par
00070   {\cf18 size_t} Capacity() {\cf17 const} {\cf17 noexcept};\par
00071 \par
00072   {\cf20 // Resizing and shrinking the vector.}\par
00073   {\cf18 void} Resize({\cf18 size_t} size);\par
00074   {\cf18 void} ShrinkToFit();\par
00075 \par
00076   {\cf20 // Getting first and last element of the vector.}\par
00077   T& Front();\par
00078   {\cf17 const} T& Front() {\cf17 const};\par
00079   T& Back();\par
00080   {\cf17 const} T& Back() {\cf17 const};\par
00081 \par
00082   {\cf20 // Destructor for the vector class.}\par
00083   ~Vector() {\cf17 noexcept};\par
00084 \par
00085  {\cf17 private}:\par
00086   {\cf20 // Method that reallocates memory for the vector.}\par
00087   {\cf18 void} Reallocate({\cf18 size_t} amount);\par
00088 \par
00092   {\cf18 size_t} size;\par
00096   {\cf18 size_t} capacity;\par
00097 \par
00101   T* data;\par
00102 \};\par
00103 \par
00108 {\cf17 template} <{\cf17 typename} T>\par
00109 Vector<T>::Vector() noexcept : size(0), capacity(0), data({\cf18 nullptr}) \{\par
00110   Reallocate(4);\par
00111 \}\par
00112 \par
00118 {\cf17 template} <{\cf17 typename} T>\par
00119 Vector<T>::Vector({\cf18 size_t} elements) noexcept\par
00120     : size(0), capacity(0), data({\cf17 nullptr}) \{\par
00121   Reallocate(elements);\par
00122 \}\par
00123 \par
00132 {\cf17 template} <{\cf17 typename} T>\par
00133 Vector<T>::Vector({\cf18 size_t} elements, {\cf17 const} T& value) noexcept\par
00134     : size(0), capacity(0), data({\cf17 nullptr}) \{\par
00135   Reallocate(elements);\par
00136   {\cf19 for} ({\cf18 size_t} i\{\}; i < capacity; ++i) \{\par
00137     data[i] = value;\par
00138   \}\par
00139 \}\par
00140 \par
00146 {\cf17 template} <{\cf17 typename} T>\par
00147 {\cf18 void} Vector<T>::Push({\cf17 const} T& value) {\cf17 noexcept} \{\par
00148   {\cf19 if} (size >= capacity) \{\par
00149     Reallocate(capacity * 2);\par
00150   \}\par
00151   data[size++] = value;\par
00152 \}\par
00153 \par
00161 {\cf17 template} <{\cf17 typename} T>\par
00162 {\cf18 void} Vector<T>::Insert({\cf17 const} T& value, {\cf18 size_t} index) \{\par
00163   {\cf19 if} (index > size) \{\par
00164     {\cf19 throw} std::runtime_error(errors::kIndexOutOfRange);\par
00165   \}\par
00166   {\cf19 if} (size + 1 > capacity) \{\par
00167     Reallocate(capacity == 0 ? 1 : capacity * 2);\par
00168   \}\par
00169   {\cf19 for} ({\cf18 size_t} i\{size\}; i > index; --i) \{\par
00170     data[i] = data[i - 1];\par
00171   \}\par
00172   data[index] = value;\par
00173   size++;\par
00174 \}\par
00175 \par
00181 {\cf17 template} <{\cf17 typename} T>\par
00182 T& Vector<T>::Pop() \{\par
00183   {\cf19 return} data[size--];\par
00184 \}\par
00185 \par
00192 {\cf17 template} <{\cf17 typename} T>\par
00193 T& Vector<T>::At({\cf18 size_t} index) \{\par
00194   {\cf19 if} (index >= size) \{\par
00195     {\cf19 throw} std::runtime_error(errors::kIndexOutOfRange);\par
00196   \}\par
00197   {\cf19 return} data[index];\par
00198 \}\par
00199 \par
00206 {\cf17 template} <{\cf17 typename} T>\par
00207 {\cf17 const} T& Vector<T>::At({\cf18 size_t} index){\cf17  const }\{\par
00208   {\cf19 if} (index >= size) \{\par
00209     {\cf19 throw} std::runtime_error(errors::kIndexOutOfRange);\par
00210   \}\par
00211   {\cf19 return} data[index];\par
00212 \}\par
00213 \par
00218 {\cf17 template} <{\cf17 typename} T>\par
00219 {\cf18 size_t} Vector<T>::Size() const noexcept \{\par
00220   {\cf19 return} size;\par
00221 \}\par
00222 \par
00227 {\cf17 template} <{\cf17 typename} T>\par
00228 {\cf18 size_t} Vector<T>::Capacity() const noexcept \{\par
00229   {\cf19 return} capacity;\par
00230 \}\par
00231 \par
00238 {\cf17 template} <{\cf17 typename} T>\par
00239 {\cf18 void} Vector<T>::Resize({\cf18 size_t} size) \{\par
00240   Reallocate(size);\par
00241 \}\par
00242 \par
00247 {\cf17 template} <{\cf17 typename} T>\par
00248 {\cf18 void} Vector<T>::ShrinkToFit() \{\par
00249   Reallocate(size);\par
00250 \}\par
00251 \par
00256 {\cf17 template} <{\cf17 typename} T>\par
00257 T& Vector<T>::Front() \{\par
00258   {\cf19 return} data[0];\par
00259 \}\par
00260 \par
00265 {\cf17 template} <{\cf17 typename} T>\par
00266 {\cf17 const} T& Vector<T>::Front(){\cf17  const }\{\par
00267   {\cf19 return} data[0];\par
00268 \}\par
00269 \par
00274 {\cf17 template} <{\cf17 typename} T>\par
00275 T& Vector<T>::Back() \{\par
00276   {\cf19 return} data[size - 1];\par
00277 \}\par
00278 \par
00283 {\cf17 template} <{\cf17 typename} T>\par
00284 {\cf17 const} T& Vector<T>::Back(){\cf17  const }\{\par
00285   {\cf19 return} data[size - 1];\par
00286 \}\par
00287 \par
00291 {\cf17 template} <{\cf17 typename} T>\par
00292 Vector<T>::~Vector() noexcept \{\par
00293   {\cf17 delete}[] data;\par
00294 \}\par
00295 \par
00302 {\cf17 template} <{\cf17 typename} T>\par
00303 {\cf18 void} Vector<T>::Reallocate({\cf18 size_t} amount) \{\par
00304   T* new_data\{{\cf17 new} T[amount]\};\par
00305   size = (amount < size) ? amount : size;\par
00306   {\cf19 for} ({\cf18 size_t} i\{\}; i < size; ++i) \{\par
00307     new_data[i] = data[i];\par
00308   \}\par
00309   {\cf17 delete}[] data;\par
00310   data = new_data;\par
00311   capacity = amount;\par
00312 \}\par
00313 \}  {\cf20 // namespace alglib}\par
00314 \par
00315 {\cf21 #endif  }{\cf20 // ALGLIB_INCLUDE_VECTOR_H_}\par
}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Index\par 
\pard\plain 
{\tc \v Index}
{\field\fldedit {\*\fldinst INDEX \\c2 \\*MERGEFORMAT}{\fldrslt INDEX}}
}
