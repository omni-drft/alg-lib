.TH "alglib::SLLQueue< T >" 3 "Version 1.0.0" "AlgLib" \" -*- nroff -*-
.ad l
.nh
.SH NAME
alglib::SLLQueue< T > \- \fBSLLQueue\fP class is a queue data structure implemented using singly linked list\&. It allocates nodes on the heap\&. Queue can grow dynamically\&. There is no limit to the amount of elements besides the memory available\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fR#include <sll_queue\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBSLLQueue\fP ()"
.br
.RI "\fBSLLQueue\fP constructor initializes the front and rear pointers to nullptr\&. "
.ti -1c
.RI "bool \fBIsEmpty\fP () const noexcept"
.br
.RI "Checks if the queue is empty by checking if the front pointer is nullptr\&. "
.ti -1c
.RI "T \fBDequeue\fP ()"
.br
.RI "Pops the value from the front of the queue and returns it\&. The front pointer is then set to the next node in the queue\&. If the front pointer is nullptr, the rear pointer is also set to nullptr\&. It deletes the node from the front, so it cannot be accesed after the operation\&. if the queue is empty, it throws a runtime error\&. "
.ti -1c
.RI "void \fBEnqueue\fP (T value) noexcept"
.br
.RI "Adds a new node to the rear of the queue\&. If the queue is empty, the front and rear pointers are set to the new node\&. Otherwise, the new node is set as the next node of the rear pointer and the rear pointer is set to the new node\&. "
.ti -1c
.RI "T \fBPeekFront\fP () const"
.br
.RI "Gets the value from the front of the queue without removing it\&. If the queue is empty, it throws a runtime error\&. "
.ti -1c
.RI "T \fBPeekRear\fP () const"
.br
.RI "Gets the value from the rear of the queue without removing it\&. If the queue is empty, it throws a runtime error\&. "
.ti -1c
.RI "\fB~SLLQueue\fP ()"
.br
.RI "Deletes all nodes from the queue\&. It starts from the front and deletes all nodes until the rear\&. It then deletes the rear node\&. "
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename T>
.br
class alglib::SLLQueue< T >"\fBSLLQueue\fP class is a queue data structure implemented using singly linked list\&. It allocates nodes on the heap\&. Queue can grow dynamically\&. There is no limit to the amount of elements besides the memory available\&. 


.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP type that will be stored in queue\&.
.RE
.PP

.PP
Definition at line \fB51\fP of file \fBsll_queue\&.h\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<typename T> \fBalglib::SLLQueue\fP< T >::SLLQueue ()"

.PP
\fBSLLQueue\fP constructor initializes the front and rear pointers to nullptr\&. 
.PP
Definition at line \fB100\fP of file \fBsll_queue\&.h\fP\&.
.SS "template<typename T> \fBalglib::SLLQueue\fP< T >::~\fBSLLQueue\fP ()"

.PP
Deletes all nodes from the queue\&. It starts from the front and deletes all nodes until the rear\&. It then deletes the rear node\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP 
.RE
.PP

.PP
Definition at line \fB184\fP of file \fBsll_queue\&.h\fP\&.
.SH "Member Function Documentation"
.PP 
.SS "template<typename T> T \fBalglib::SLLQueue\fP< T >::Dequeue ()"

.PP
Pops the value from the front of the queue and returns it\&. The front pointer is then set to the next node in the queue\&. If the front pointer is nullptr, the rear pointer is also set to nullptr\&. It deletes the node from the front, so it cannot be accesed after the operation\&. if the queue is empty, it throws a runtime error\&. 
.PP
\fBReturns\fP
.RS 4

.RE
.PP

.PP
Definition at line \fB120\fP of file \fBsll_queue\&.h\fP\&.
.SS "template<typename T> void \fBalglib::SLLQueue\fP< T >::Enqueue (T value)\fR [noexcept]\fP"

.PP
Adds a new node to the rear of the queue\&. If the queue is empty, the front and rear pointers are set to the new node\&. Otherwise, the new node is set as the next node of the rear pointer and the rear pointer is set to the new node\&. 
.PP
\fBParameters\fP
.RS 4
\fIvalue\fP value to be inserted into queue\&.
.RE
.PP

.PP
Definition at line \fB141\fP of file \fBsll_queue\&.h\fP\&.
.SS "template<typename T> bool \fBalglib::SLLQueue\fP< T >::IsEmpty () const\fR [noexcept]\fP"

.PP
Checks if the queue is empty by checking if the front pointer is nullptr\&. 
.PP
\fBReturns\fP
.RS 4
true if empty, false if not\&.
.RE
.PP

.PP
Definition at line \fB107\fP of file \fBsll_queue\&.h\fP\&.
.SS "template<typename T> T \fBalglib::SLLQueue\fP< T >::PeekFront () const"

.PP
Gets the value from the front of the queue without removing it\&. If the queue is empty, it throws a runtime error\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP 
.RE
.PP
\fBReturns\fP
.RS 4
.RE
.PP

.PP
Definition at line \fB157\fP of file \fBsll_queue\&.h\fP\&.
.SS "template<typename T> T \fBalglib::SLLQueue\fP< T >::PeekRear () const"

.PP
Gets the value from the rear of the queue without removing it\&. If the queue is empty, it throws a runtime error\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP 
.RE
.PP
\fBReturns\fP
.RS 4
.RE
.PP

.PP
Definition at line \fB171\fP of file \fBsll_queue\&.h\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for AlgLib from the source code\&.
